var commerceWebservicesV2 =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = msRest;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = __webpack_require__(2);
const msRest = __webpack_require__(0);
const Models = __webpack_require__(3);
exports.CommerceWebservicesV2Models = Models;
const Mappers = __webpack_require__(4);
exports.CommerceWebservicesV2Mappers = Mappers;
const commerceWebservicesV2Context_1 = __webpack_require__(5);
const WebResource = msRest.WebResource;
class CommerceWebservicesV2 extends commerceWebservicesV2Context_1.CommerceWebservicesV2Context {
    /**
     * @class
     * Initializes a new instance of the CommerceWebservicesV2 class.
     * @constructor
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     */
    constructor(baseUri, options) {
        super(baseUri, options);
        this.serializer = new msRest.Serializer(Mappers);
    }
    // methods on the client.
    /**
     * @summary Get a list of supported payment card types.
     *
     * Lists supported payment card types.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCardTypesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCardTypesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/cardtypes",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CardTypeList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CardTypeList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of catalogs
     *
     * Returns all catalogs with versions defined for the base store.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCatalogsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCatalogsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/catalogs",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CatalogList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CatalogList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a catalog
     *
     * Returns information about a catalog based on its ID, along with the versions defined for the
     * current base store.
     *
     * @param {string} catalogId Catalog identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCatalogOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCatalogWithHttpOperationResponse(catalogId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    catalogId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/catalogs/{catalogId}",
                    urlParameters: [
                        {
                            parameterPath: "catalogId",
                            mapper: {
                                required: true,
                                serializedName: "catalogId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Catalog
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Catalog;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get information about catalog version
     *
     * Returns information about the catalog version that exists for the current base store.
     *
     * @param {string} catalogId Catalog identifier
     *
     * @param {string} catalogVersionId Catalog version identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCatalogVersionOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCatalogVersionWithHttpOperationResponse(catalogId, catalogVersionId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    catalogId,
                    catalogVersionId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/catalogs/{catalogId}/{catalogVersionId}",
                    urlParameters: [
                        {
                            parameterPath: "catalogId",
                            mapper: {
                                required: true,
                                serializedName: "catalogId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "catalogVersionId",
                            mapper: {
                                required: true,
                                serializedName: "catalogVersionId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CatalogVersion
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CatalogVersion;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get information about catagory in a catalog version
     *
     * Returns information about a specified category that exists in a catalog version available for
     * the current base store.
     *
     * @param {string} catalogId Catalog identifier
     *
     * @param {string} catalogVersionId Catalog version identifier
     *
     * @param {string} categoryId Category identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCategoriesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCategoriesWithHttpOperationResponse(catalogId, catalogVersionId, categoryId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    catalogId,
                    catalogVersionId,
                    categoryId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/catalogs/{catalogId}/{catalogVersionId}/categories/{categoryId}",
                    urlParameters: [
                        {
                            parameterPath: "catalogId",
                            mapper: {
                                required: true,
                                serializedName: "catalogId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "catalogVersionId",
                            mapper: {
                                required: true,
                                serializedName: "catalogVersionId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "categoryId",
                            mapper: {
                                required: true,
                                serializedName: "categoryId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CategoryHierarchy
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CategoryHierarchy;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get components' data by id given in body
     *
     * Given a list of component identifiers in body, return cms component data.
     *
     * @param {ComponentIDList} componentIdList List of Component identifiers
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetComponentByIdListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getComponentByIdListWithHttpOperationResponse(componentIdList, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let catalogCode = (options && options.catalogCode !== undefined) ? options.catalogCode : undefined;
            let productCode = (options && options.productCode !== undefined) ? options.productCode : undefined;
            let categoryCode = (options && options.categoryCode !== undefined) ? options.categoryCode : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 10;
            let sort = (options && options.sort !== undefined) ? options.sort : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    componentIdList,
                    catalogCode,
                    productCode,
                    categoryCode,
                    fields,
                    currentPage,
                    pageSize,
                    sort,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/cms/components",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "catalogCode",
                            mapper: {
                                serializedName: "catalogCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "productCode",
                            mapper: {
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "categoryCode",
                            mapper: {
                                serializedName: "categoryCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 10,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "componentIdList",
                        mapper: Object.assign({}, Mappers.ComponentIDList, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.ListAdaptedComponents
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ListAdaptedComponents;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get component data
     *
     * Given a component identifier, return cms component data.
     *
     * @param {string} componentId Component identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetComponentByIdOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getComponentByIdWithHttpOperationResponse(componentId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let catalogCode = (options && options.catalogCode !== undefined) ? options.catalogCode : undefined;
            let productCode = (options && options.productCode !== undefined) ? options.productCode : undefined;
            let categoryCode = (options && options.categoryCode !== undefined) ? options.categoryCode : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    componentId,
                    catalogCode,
                    productCode,
                    categoryCode,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/cms/components/{componentId}",
                    urlParameters: [
                        {
                            parameterPath: "componentId",
                            mapper: {
                                required: true,
                                serializedName: "componentId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "catalogCode",
                            mapper: {
                                serializedName: "catalogCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "productCode",
                            mapper: {
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "categoryCode",
                            mapper: {
                                serializedName: "categoryCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            }
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            };
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get page data with list of cms content slots
     *
     * Given a page identifier, return the page data with a list of cms content slots, each of which
     * contains a list of cms component data.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetPageDataOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPageDataWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let pageType = (options && options.pageType !== undefined) ? options.pageType : 'ContentPage';
            let pageLabelOrId = (options && options.pageLabelOrId !== undefined) ? options.pageLabelOrId : undefined;
            let code = (options && options.code !== undefined) ? options.code : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    pageType,
                    pageLabelOrId,
                    code,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/cms/pages",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "pageType",
                            mapper: {
                                serializedName: "pageType",
                                defaultValue: 'ContentPage',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "pageLabelOrId",
                            mapper: {
                                serializedName: "pageLabelOrId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "code",
                            mapper: {
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CMSPage
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CMSPage;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of available currencies.
     *
     * Lists all available currencies (all usable currencies for the current store). If the list of
     * currencies for a base store is empty, a list of all currencies available in the system is
     * returned.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCurrenciesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCurrenciesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/currencies",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CurrencyList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CurrencyList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get all subgroups of a customergroup.
     *
     * Returns all customer groups that are direct subgroups of a customergroup.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetAllCustomerGroupsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getAllCustomerGroupsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    currentPage,
                    pageSize,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.UserGroupList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.UserGroupList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates a new customer group.
     *
     * Creates a new customer group that is a direct subgroup of a customergroup.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {UserGroup} userGroup User group object with id and name.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createNewCustomerGroupPrimWithHttpOperationResponse(userGroup, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    userGroup,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "userGroup",
                        mapper: Object.assign({}, Mappers.UserGroup, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a specific customer group.
     *
     * Returns a customer group with a specific groupId.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} groupId Group identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCustomerGroupOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCustomerGroupWithHttpOperationResponse(groupId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    groupId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups/{groupId}",
                    urlParameters: [
                        {
                            parameterPath: "groupId",
                            mapper: {
                                required: true,
                                serializedName: "groupId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.UserGroup
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.UserGroup;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Sets members for a user group.
     *
     * Sets members for a user group. The list of existing members is overwritten with a new one.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} groupId Group identifier.
     *
     * @param {MemberList} members List of users to set for customer group.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setUserListForCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    groupId,
                    members,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups/{groupId}/members",
                    urlParameters: [
                        {
                            parameterPath: "groupId",
                            mapper: {
                                required: true,
                                serializedName: "groupId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "members",
                        mapper: Object.assign({}, Mappers.MemberList, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Assigns user(s) to a customer group.
     *
     * Assigns user(s) to a customer group.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} groupId Group identifier.
     *
     * @param {MemberList} members List of users to assign to customer group.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    assignUserToCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    groupId,
                    members,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups/{groupId}/members",
                    urlParameters: [
                        {
                            parameterPath: "groupId",
                            mapper: {
                                required: true,
                                serializedName: "groupId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "members",
                        mapper: Object.assign({}, Mappers.MemberList, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete a user from a customer group.
     *
     * Removes user from a customer group.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} groupId Group identifier.
     *
     * @param {string} userId User identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removeUsersFromCustomerGroupWithHttpOperationResponse(groupId, userId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    groupId,
                    userId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups/{groupId}/members/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "groupId",
                            mapper: {
                                required: true,
                                serializedName: "groupId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of supported countries.
     *
     * Lists all supported delivery countries for the current store. The list is sorted alphabetically.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetDeliveryCountriesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getDeliveryCountriesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/deliverycountries",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CountryList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CountryList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of product exports.
     *
     * Used for product export. Depending on the timestamp parameter, it can return all products or
     * only products modified after the given time.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2ExportProductsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    exportProductsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let catalog = (options && options.catalog !== undefined) ? options.catalog : undefined;
            let version = (options && options.version !== undefined) ? options.version : undefined;
            let timestamp = (options && options.timestamp !== undefined) ? options.timestamp : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    currentPage,
                    pageSize,
                    catalog,
                    version,
                    timestamp,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/export/products",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "catalog",
                            mapper: {
                                serializedName: "catalog",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "version",
                            mapper: {
                                serializedName: "version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "timestamp",
                            mapper: {
                                serializedName: "timestamp",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ProductList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ProductList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of orders with status updates
     *
     * Returns the orders that have changed status. Returns only the elements from the current baseSite
     * that have been updated after the provided timestamp.
     *
     * @param {string} timestamp Only items newer than the given parameter are retrieved. This
     * parameter should be in ISO-8601 format (for example, 2018-01-09T16:28:45+0000).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2OrderStatusFeedOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    orderStatusFeedWithHttpOperationResponse(timestamp, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    timestamp,
                    baseSiteId,
                    fields
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/feeds/orders/statusfeed",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "timestamp",
                            mapper: {
                                required: true,
                                serializedName: "timestamp",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.OrderStatusUpdateElementList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.OrderStatusUpdateElementList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Generates a token to restore a customer's forgotten password.
     *
     * Generates a token to restore a customer's forgotten password.
     *
     * @param {string} userId Customer's user id. Customer user id is case insensitive.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    restorePasswordWithHttpOperationResponse(userId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    userId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/forgottenpasswordtokens",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        201: {},
                        202: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of available languages.
     *
     * Lists all available languages (all languages used for a particular store). If the list of
     * languages for a base store is empty, a list of all languages available in the system will be
     * returned.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetLanguagesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getLanguagesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/languages",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.LanguageList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.LanguageList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a order
     *
     * Returns details of a specific order based on the order GUID (Globally Unique Identifier) or the
     * order CODE. The response contains detailed order information.
     *
     * @param {string} code Order GUID (Globally Unique Identifier) or order CODE
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetOrderOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getOrderWithHttpOperationResponse(code, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    code,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/orders/{code}",
                    urlParameters: [
                        {
                            parameterPath: "code",
                            mapper: {
                                required: true,
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Order
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Order;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get products added to the express update feed
     *
     * Returns products added to the express update feed. Returns only elements updated after the
     * provided timestamp. The queue is cleared using a defined cronjob.
     *
     * @param {string} timestamp Only items newer than the given parameter are retrieved from the
     * queue. This parameter should be in ISO-8601 format.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2ExpressUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    expressUpdateWithHttpOperationResponse(timestamp, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let catalog = (options && options.catalog !== undefined) ? options.catalog : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    timestamp,
                    catalog,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/expressupdate",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "timestamp",
                            mapper: {
                                required: true,
                                serializedName: "timestamp",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "catalog",
                            mapper: {
                                serializedName: "catalog",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ProductExpressUpdateElementList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ProductExpressUpdateElementList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of products and additional data
     *
     * Returns a list of products and additional data, such as available facets, available sorting, and
     * pagination options. It can also include spelling suggestions. To make spelling suggestions work,
     * you need to make sure that "enableSpellCheck" on the SearchQuery is set to "true" (by default,
     * it should already be set to "true"). You also need to have indexed properties configured to be
     * used for spellchecking.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2SearchProductsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    searchProductsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = (options && options.query !== undefined) ? options.query : undefined;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let sort = (options && options.sort !== undefined) ? options.sort : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            let searchQueryContext = (options && options.searchQueryContext !== undefined) ? options.searchQueryContext : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    query,
                    currentPage,
                    pageSize,
                    sort,
                    fields,
                    searchQueryContext,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/search",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "query",
                            mapper: {
                                serializedName: "query",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "searchQueryContext",
                            mapper: {
                                serializedName: "searchQueryContext",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ProductSearchPage
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ProductSearchPage;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a header with total number of products
     *
     * In the response header, the "x-total-count" indicates the total number of products satisfying a
     * query.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2CountSearchProductsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    countSearchProductsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = (options && options.query !== undefined) ? options.query : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    query,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/search",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "query",
                            mapper: {
                                serializedName: "query",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of available suggestions
     *
     * Returns a list of all available suggestions related to a given term and limits the results to a
     * specific value of the max parameter.
     *
     * @param {string} term Specified term
     *
     * @param {number} max Specifies the limit of results.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetSuggestionsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getSuggestionsWithHttpOperationResponse(term, max, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    term,
                    max,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/suggestions",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "term",
                            mapper: {
                                required: true,
                                serializedName: "term",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "max",
                            mapper: {
                                required: true,
                                serializedName: "max",
                                defaultValue: 10,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SuggestionList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SuggestionList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get product details
     *
     * Returns details of a single product according to a product code.
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetProductByCodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getProductByCodeWithHttpOperationResponse(productCode, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Product
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Product;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a product reference
     *
     * Returns references for a product with a given product code. Reference type specifies which
     * references to return.
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} referenceType Reference type according to enum ProductReferenceTypeEnum
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2ExportProductReferencesOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    exportProductReferencesWithHttpOperationResponse(productCode, referenceType, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 2147483647;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    pageSize,
                    referenceType,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/references",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 2147483647,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "referenceType",
                            mapper: {
                                required: true,
                                serializedName: "referenceType",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ProductReferenceList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ProductReferenceList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get reviews for a product
     *
     * Returns the reviews for a product with a given product code.
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetProductReviewsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getProductReviewsWithHttpOperationResponse(productCode, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let maxCount = (options && options.maxCount !== undefined) ? options.maxCount : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    maxCount,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/reviews",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "maxCount",
                            mapper: {
                                serializedName: "maxCount",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ReviewList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ReviewList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates a new customer review as an anonymous user
     *
     * Creates a new customer review as an anonymous user.
     *
     * @param {string} productCode Product identifier
     *
     * @param {Review} review Object contains review details like : rating, alias, headline, comment
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2CreateReviewPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createReviewPrimWithHttpOperationResponse(productCode, review, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    review,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/reviews",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "review",
                        mapper: Object.assign({}, Mappers.Review, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.Review
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Review;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a product's stock level
     *
     * Returns a product's stock levels sorted by distance from the specified location, which is
     * provided using the free-text "location" parameter, or by using the longitude and latitude
     * parameters. The following two sets of parameters are available: location (required), currentPage
     * (optional), pageSize (optional); or longitude (required), latitude (required), currentPage
     * (optional), pageSize(optional).
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2SearchProductStockByLocationOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    searchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let location = (options && options.location !== undefined) ? options.location : undefined;
            let latitude = (options && options.latitude !== undefined) ? options.latitude : undefined;
            let longitude = (options && options.longitude !== undefined) ? options.longitude : undefined;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    location,
                    latitude,
                    longitude,
                    currentPage,
                    pageSize,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/stock",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "location",
                            mapper: {
                                serializedName: "location",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "latitude",
                            mapper: {
                                serializedName: "latitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "longitude",
                            mapper: {
                                serializedName: "longitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.StoreFinderStockSearchPage
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.StoreFinderStockSearchPage;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get header with a total number of product's stock levels
     *
     * In the response header, the "x-total-count" indicates the total number of a product's stock
     * levels. The following two sets of parameters are available: location (required); or longitude
     * (required), and latitude (required).
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2CountSearchProductStockByLocationOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    countSearchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let location = (options && options.location !== undefined) ? options.location : undefined;
            let latitude = (options && options.latitude !== undefined) ? options.latitude : undefined;
            let longitude = (options && options.longitude !== undefined) ? options.longitude : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    location,
                    latitude,
                    longitude,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/stock",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "location",
                            mapper: {
                                serializedName: "location",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "latitude",
                            mapper: {
                                serializedName: "latitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "longitude",
                            mapper: {
                                serializedName: "longitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a product's stock level for a store
     *
     * Returns a product's stock level for a particular store (in other words, for a particular point
     * of sale).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} storeName Store identifier
     *
     * @param {CommerceWebservicesV2GetStockDataOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getStockDataWithHttpOperationResponse(baseSiteId, productCode, storeName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    productCode,
                    storeName,
                    fields
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/stock/{storeName}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "storeName",
                            mapper: {
                                required: true,
                                serializedName: "storeName",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Stock
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Stock;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of promotions
     *
     * Returns promotions defined for a current base site. Requests pertaining to promotions have been
     * developed for the previous version of promotions and vouchers and therefore some of them are
     * currently not compatible with the new promotion engine.
     *
     * @param {Type} type Defines what type of promotions should be returned. Values supported for that
     * parameter are: <ul><li>all: All available promotions are returned</li><li>product: Only product
     * promotions are returned</li><li>order: Only order promotions are returned</li></ul>. Possible
     * values include: 'all', 'product', 'order'
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetPromotionsPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPromotionsPrimWithHttpOperationResponse(type, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let promotionGroup = (options && options.promotionGroup !== undefined) ? options.promotionGroup : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    type,
                    promotionGroup,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/promotions",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "type",
                            mapper: {
                                required: true,
                                serializedName: "type",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "promotionGroup",
                            mapper: {
                                serializedName: "promotionGroup",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PromotionList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PromotionList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a promotion based on code
     *
     * Returns details of a single promotion specified by a promotion code. Requests pertaining to
     * promotions have been developed for the previous version of promotions and vouchers and therefore
     * some of them are currently not compatible with the new promotion engine.
     *
     * @param {string} code Promotion identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetPromotionByCodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPromotionByCodeWithHttpOperationResponse(code, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    code,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/promotions/{code}",
                    urlParameters: [
                        {
                            parameterPath: "code",
                            mapper: {
                                required: true,
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Promotion
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Promotion;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of store locations
     *
     * Lists all store locations that are near the location specified in a query or based on latitude
     * and longitude.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2LocationSearchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    locationSearchWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = (options && options.query !== undefined) ? options.query : undefined;
            let latitude = (options && options.latitude !== undefined) ? options.latitude : undefined;
            let longitude = (options && options.longitude !== undefined) ? options.longitude : undefined;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let sort = (options && options.sort !== undefined) ? options.sort : 'asc';
            let radius = (options && options.radius !== undefined) ? options.radius : 100000;
            let accuracy = (options && options.accuracy !== undefined) ? options.accuracy : 0;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    query,
                    latitude,
                    longitude,
                    currentPage,
                    pageSize,
                    sort,
                    radius,
                    accuracy,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/stores",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "query",
                            mapper: {
                                serializedName: "query",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "latitude",
                            mapper: {
                                serializedName: "latitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "longitude",
                            mapper: {
                                serializedName: "longitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                defaultValue: 'asc',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "radius",
                            mapper: {
                                serializedName: "radius",
                                defaultValue: 100000,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "accuracy",
                            mapper: {
                                serializedName: "accuracy",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.StoreFinderSearchPage
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.StoreFinderSearchPage;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a header with the number of store locations
     *
     * In the response header, the "x-total-count" indicates the number of all store locations that are
     * near the location specified in a query, or based on latitude and longitude.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2CountLocationSearchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    countLocationSearchWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = (options && options.query !== undefined) ? options.query : undefined;
            let latitude = (options && options.latitude !== undefined) ? options.latitude : undefined;
            let longitude = (options && options.longitude !== undefined) ? options.longitude : undefined;
            let radius = (options && options.radius !== undefined) ? options.radius : 100000;
            let accuracy = (options && options.accuracy !== undefined) ? options.accuracy : 0;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    query,
                    latitude,
                    longitude,
                    radius,
                    accuracy,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/stores",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "query",
                            mapper: {
                                serializedName: "query",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "latitude",
                            mapper: {
                                serializedName: "latitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "longitude",
                            mapper: {
                                serializedName: "longitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "radius",
                            mapper: {
                                serializedName: "radius",
                                defaultValue: 100000,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "accuracy",
                            mapper: {
                                serializedName: "accuracy",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a store location
     *
     * Returns store location based on its unique name.
     *
     * @param {string} storeId Store identifier (currently store name)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2LocationDetailsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    locationDetailsWithHttpOperationResponse(storeId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    storeId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/stores/{storeId}",
                    urlParameters: [
                        {
                            parameterPath: "storeId",
                            mapper: {
                                required: true,
                                serializedName: "storeId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PointOfService
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PointOfService;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of all localized titles.
     *
     * Lists all localized titles.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetTitlesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getTitlesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/titles",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.TitleList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.TitleList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary  Registers a customer
     *
     * Registers a customer. There are two options for registering a customer. The first option
     * requires the following parameters: login, password, firstName, lastName, titleCode. The second
     * option converts a guest to a customer. In this case, the required parameters are: guid,
     * password.
     *
     * @param {UserSignUp} user User's object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2RegisterUserPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    registerUserPrimWithHttpOperationResponse(user, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    user,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "user",
                        mapper: Object.assign({}, Mappers.UserSignUp, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.User
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.User;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get customer profile
     *
     * Returns customer profile.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getUserWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.User
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.User;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates customer profile
     *
     * Updates customer profile. Attributes not provided in the request body will be defined again (set
     * to null or default).
     *
     * @param {User} user User's object
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    putUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    user,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "user",
                        mapper: Object.assign({}, Mappers.User, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete customer profile
     *
     * Removes customer profile.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    deactivateUserWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates customer profile
     *
     * Updates customer profile. Only attributes provided in the request body will be changed.
     *
     * @param {User} user User's object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    updateUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    user,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "user",
                        mapper: Object.assign({}, Mappers.User, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get customer's addresses
     *
     * Returns customer's addresses.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetAddressesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getAddressesWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.AddressList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.AddressList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates a new address.
     *
     * Creates a new address.
     *
     * @param {Address} address Address object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2CreateAddressPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    address,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.Address
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Address;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Verifies address
     *
     * Verifies address.
     *
     * @param {Address} address Address object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2VerifyAddressPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    verifyAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    address,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/verification",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.AddressValidation
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.AddressValidation;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get info about address
     *
     * Returns detailed information about address with a given id.
     *
     * @param {string} addressId Address identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetAddressOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/{addressId}",
                    urlParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Address
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Address;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates the address
     *
     * Updates the address. Attributes not provided in the request will be defined again (set to null
     * or default).
     *
     * @param {string} addressId Address identifier.
     *
     * @param {Address} address Address object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    putAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    address,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/{addressId}",
                    urlParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete customer's address
     *
     * Removes customer's address.
     *
     * @param {string} addressId Address identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    deleteAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/{addressId}",
                    urlParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates the address
     *
     * Updates the address. Only attributes provided in the request body will be changed.
     *
     * @param {string} addressId Address identifier.
     *
     * @param {Address} address Address object
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    patchAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    address,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/{addressId}",
                    urlParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get all customer carts.
     *
     * Lists all customer carts.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetCartsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartsWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            let savedCartsOnly = (options && options.savedCartsOnly !== undefined) ? options.savedCartsOnly : false;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let sort = (options && options.sort !== undefined) ? options.sort : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    savedCartsOnly,
                    currentPage,
                    pageSize,
                    sort,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "savedCartsOnly",
                            mapper: {
                                serializedName: "savedCartsOnly",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CartList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CartList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates or restore a cart for a user.
     *
     * Creates a new cart or restores an anonymous cart as a user's cart (if an old Cart Id is given in
     * the request).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2CreateCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createCartWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let oldCartId = (options && options.oldCartId !== undefined) ? options.oldCartId : undefined;
            let toMergeCartGuid = (options && options.toMergeCartGuid !== undefined) ? options.toMergeCartGuid : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    oldCartId,
                    toMergeCartGuid,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "oldCartId",
                            mapper: {
                                serializedName: "oldCartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "toMergeCartGuid",
                            mapper: {
                                serializedName: "toMergeCartGuid",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        201: {
                            bodyMapper: Mappers.Cart
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Cart;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a cart with a given identifier.
     *
     * Returns the cart with a given identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Cart
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Cart;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Deletes a cart with a given cart id.
     *
     * Deletes a cart with a given cart id.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    deleteCartWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates a delivery address for the cart.
     *
     * Creates an address and assigns it to the cart as the delivery address.
     *
     * @param {Address} address Request body parameter that contains details such as the customer's
     * first name (firstName), the customer's last name (lastName), the customer's title (titleCode),
     * the country (country.isocode), the first part of the address (line1), the second part of the
     * address (line2), the town (town), the postal code (postalCode), and the region (region.isocode).
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2CreateAndSetAddressPrimOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createAndSetAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    address,
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/addresses/delivery",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.Address
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Address;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Sets a delivery address for the cart.
     *
     * Sets a delivery address for the cart. The address country must be placed among the delivery
     * countries of the current base store.
     *
     * @param {string} addressId Address identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setCartDeliveryAddressWithHttpOperationResponse(addressId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/addresses/delivery",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete the delivery address from the cart.
     *
     * Removes the delivery address from the cart.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removeCartDeliveryAddressWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/addresses/delivery",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Explicitly clones a cart.
     *
     * Explicitly clones a cart.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2CloneSaveCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    cloneSaveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let name = (options && options.name !== undefined) ? options.name : undefined;
            let description = (options && options.description !== undefined) ? options.description : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    name,
                    description,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/clonesavedcart",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "name",
                            mapper: {
                                serializedName: "name",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "description",
                            mapper: {
                                serializedName: "description",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get the delivery mode selected for the cart.
     *
     * Returns the delivery mode selected for the cart.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetCartDeliveryModeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/deliverymode",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.DeliveryMode
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.DeliveryMode;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Sets the delivery mode for a cart.
     *
     * Sets the delivery mode with a given identifier for the cart.
     *
     * @param {string} deliveryModeId Delivery mode identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setCartDeliveryModeWithHttpOperationResponse(deliveryModeId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    deliveryModeId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/deliverymode",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "deliveryModeId",
                            mapper: {
                                required: true,
                                serializedName: "deliveryModeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete the delivery mode from the cart.
     *
     * Removes the delivery mode from the cart.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removeDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/deliverymode",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get all delivery modes for the current store and delivery address.
     *
     * Returns all delivery modes supported for the current base store and cart delivery address. A
     * delivery address must be set for the cart, otherwise an empty list will be returned.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetSupportedDeliveryModesOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getSupportedDeliveryModesWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/deliverymodes",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.DeliveryModeList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.DeliveryModeList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Assigns an email to the cart.
     *
     * Assigns an email to the cart. This step is required to make a guest checkout.
     *
     * @param {string} email Email of the guest user. It will be used during the checkout process.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    guestLoginWithHttpOperationResponse(email, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    email,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/email",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "email",
                            mapper: {
                                required: true,
                                serializedName: "email",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get cart entries.
     *
     * Returns cart entries.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetCartEntriesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartEntriesWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.OrderEntryList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.OrderEntryList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Adds a product to the cart.
     *
     * Adds a product to the cart.
     *
     * @param {OrderEntry} entry Request body parameter that contains details such as the product code
     * (product.code), the quantity of product (quantity), and the pickup store name
     * (deliveryPointOfService.name).
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2AddCartEntryPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    addCartEntryPrimWithHttpOperationResponse(entry, userId, cartId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entry,
                    fields,
                    userId,
                    cartId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries",
                    urlParameters: [
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "entry",
                        mapper: Object.assign({}, Mappers.OrderEntry, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.CartModification
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CartModification;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get the details of the cart entries.
     *
     * Returns the details of the cart entries.
     *
     * @param {number} entryNumber The entry number. Each entry in a cart has an entry number. Cart
     * entries are numbered in ascending order, starting with zero (0).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetCartEntryOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entryNumber,
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries/{entryNumber}",
                    urlParameters: [
                        {
                            parameterPath: "entryNumber",
                            mapper: {
                                required: true,
                                serializedName: "entryNumber",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.OrderEntry
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.OrderEntry;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Set quantity and store details of a cart entry.
     *
     * Updates the quantity of a single cart entry and the details of the store where the cart entry
     * will be picked up. Attributes not provided in request will be defined again (set to null or
     * default)
     *
     * @param {number} entryNumber The entry number. Each entry in a cart has an entry number. Cart
     * entries are numbered in ascending order, starting with zero (0).
     *
     * @param {OrderEntry} entry Request body parameter that contains details such as the quantity of
     * product (quantity), and the pickup store name (deliveryPointOfService.name)
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2SetCartEntryPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entryNumber,
                    entry,
                    fields,
                    userId,
                    cartId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries/{entryNumber}",
                    urlParameters: [
                        {
                            parameterPath: "entryNumber",
                            mapper: {
                                required: true,
                                serializedName: "entryNumber",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "entry",
                        mapper: Object.assign({}, Mappers.OrderEntry, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.CartModification
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CartModification;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Deletes cart entry.
     *
     * Deletes cart entry.
     *
     * @param {number} entryNumber The entry number. Each entry in a cart has an entry number. Cart
     * entries are numbered in ascending order, starting with zero (0).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removeCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entryNumber,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries/{entryNumber}",
                    urlParameters: [
                        {
                            parameterPath: "entryNumber",
                            mapper: {
                                required: true,
                                serializedName: "entryNumber",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Update quantity and store details of a cart entry.
     *
     * Updates the quantity of a single cart entry and the details of the store where the cart entry
     * will be picked up.
     *
     * @param {number} entryNumber The entry number. Each entry in a cart has an entry number. Cart
     * entries are numbered in ascending order, starting with zero (0).
     *
     * @param {OrderEntry} entry Request body parameter that contains details such as the quantity of
     * product (quantity), and the pickup store name (deliveryPointOfService.name)
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2UpdateCartEntryPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    updateCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entryNumber,
                    entry,
                    fields,
                    userId,
                    cartId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries/{entryNumber}",
                    urlParameters: [
                        {
                            parameterPath: "entryNumber",
                            mapper: {
                                required: true,
                                serializedName: "entryNumber",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "entry",
                        mapper: Object.assign({}, Mappers.OrderEntry, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.CartModification
                        },
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CartModification;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Flag a cart for deletion.
     *
     * Flags a cart for deletion (the cart doesn't have corresponding save cart attributes anymore).
     * The cart is not actually deleted from the database. But with the removal of the saved cart
     * attributes, this cart will be taken care of by the cart removal job just like any other cart.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2FlagForDeletionOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    flagForDeletionWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/flagForDeletion",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Defines and assigns details of a new credit card payment to the cart.
     *
     * Defines the details of a new credit card, and assigns this payment option to the cart.
     *
     * @param {PaymentDetails} paymentDetails Request body parameter that contains details such as the
     * name on the card (accountHolderName), the card number (cardNumber), the card type
     * (cardType.code), the month of the expiry date (expiryMonth), the year of the expiry date
     * (expiryYear), whether the payment details should be saved (saved), whether the payment details
     * should be set as default (defaultPaymentInfo), and the billing address
     * (billingAddress.firstName, billingAddress.lastName, billingAddress.titleCode,
     * billingAddress.country.isocode, billingAddress.line1, billingAddress.line2, billingAddress.town,
     * billingAddress.postalCode, billingAddress.region.isocode)
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2AddPaymentDetailsPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    addPaymentDetailsPrimWithHttpOperationResponse(paymentDetails, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetails,
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/paymentdetails",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "paymentDetails",
                        mapper: Object.assign({}, Mappers.PaymentDetails, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.PaymentDetails
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PaymentDetails;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Sets credit card payment details for the cart.
     *
     * Sets credit card payment details for the cart.
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/paymentdetails",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get information about promotions applied on cart.
     *
     * Returns information about the promotions applied on the cart. Requests pertaining to promotions
     * have been developed for the previous version of promotions and vouchers, and as a result, some
     * of them are currently not compatible with the new promotions engine.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetPromotionsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPromotionsWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/promotions",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PromotionResultList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PromotionResultList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Enables promotions based on the promotionsId of the cart.
     *
     * Enables a promotion for the order based on the promotionId defined for the cart. Requests
     * pertaining to promotions have been developed for the previous version of promotions and
     * vouchers, and as a result, some of them are currently not compatible with the new promotions
     * engine.
     *
     * @param {string} promotionId Promotion identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    applyPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    promotionId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/promotions",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "promotionId",
                            mapper: {
                                required: true,
                                serializedName: "promotionId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get information about promotions applied on cart.
     *
     * Returns information about a promotion (with a specific promotionId), that has been applied on
     * the cart. Requests pertaining to promotions have been developed for the previous version of
     * promotions and vouchers, and as a result, some of them are currently not compatible with the new
     * promotions engine.
     *
     * @param {string} promotionId Promotion identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetPromotionOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    promotionId,
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/promotions/{promotionId}",
                    urlParameters: [
                        {
                            parameterPath: "promotionId",
                            mapper: {
                                required: true,
                                serializedName: "promotionId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PromotionResultList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PromotionResultList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Disables the promotion based on the promotionsId of the cart.
     *
     * Disables the promotion for the order based on the promotionId defined for the cart. Requests
     * pertaining to promotions have been developed for the previous version of promotions and
     * vouchers, and as a result, some of them are currently not compatible with the new promotions
     * engine.
     *
     * @param {string} promotionId Promotion identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removePromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    promotionId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/promotions/{promotionId}",
                    urlParameters: [
                        {
                            parameterPath: "promotionId",
                            mapper: {
                                required: true,
                                serializedName: "promotionId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Restore a saved cart.
     *
     * Restore a saved cart.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2RestoreSavedCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    restoreSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/restoresavedcart",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Explicitly saves a cart.
     *
     * Explicitly saves a cart.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2SaveCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    saveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let saveCartName = (options && options.saveCartName !== undefined) ? options.saveCartName : undefined;
            let saveCartDescription = (options && options.saveCartDescription !== undefined) ? options.saveCartDescription : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    saveCartName,
                    saveCartDescription,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/save",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "saveCartName",
                            mapper: {
                                serializedName: "saveCartName",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "saveCartDescription",
                            mapper: {
                                serializedName: "saveCartDescription",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a saved cart.
     *
     * Returns a saved cart for an authenticated user. The cart is identified using the "cartId"
     * parameter.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetSavedCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/savedcart",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of vouchers applied to the cart.
     *
     * Returns a list of vouchers applied to the cart.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetVouchersOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getVouchersWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/vouchers",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.VoucherList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.VoucherList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Applies a voucher based on the voucherId defined for the cart.
     *
     * Applies a voucher based on the voucherId defined for the cart.
     *
     * @param {string} voucherId Voucher identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    applyVoucherForCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    voucherId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/vouchers",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "voucherId",
                            mapper: {
                                required: true,
                                serializedName: "voucherId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete a voucher defined for the current cart.
     *
     * Removes a voucher based on the voucherId defined for the current cart.
     *
     * @param {string} voucherId Voucher identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    releaseVoucherFromCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    voucherId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/vouchers/{voucherId}",
                    urlParameters: [
                        {
                            parameterPath: "voucherId",
                            mapper: {
                                required: true,
                                serializedName: "voucherId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get all customer groups of a customer.
     *
     * Returns all customer groups of a customer.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetAllCustomerGroupsForCustomerOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getAllCustomerGroupsForCustomerWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/customergroups",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.UserGroupList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.UserGroupList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Changes customer's login name.
     *
     * Changes a customer's login name. Requires the customer's current password.
     *
     * @param {string} newLogin Customer's new login name. Customer login is case insensitive.
     *
     * @param {string} password Customer's current password.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    changeLoginWithHttpOperationResponse(newLogin, password, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    newLogin,
                    password,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/login",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "newLogin",
                            mapper: {
                                required: true,
                                serializedName: "newLogin",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "password",
                            mapper: {
                                required: true,
                                serializedName: "password",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get order history for user
     *
     * Returns order history data for all orders placed by a specified user for a specified base store.
     * The response can display the results across multiple pages, if required.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetOrdersForUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let statuses = (options && options.statuses !== undefined) ? options.statuses : undefined;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let sort = (options && options.sort !== undefined) ? options.sort : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    statuses,
                    currentPage,
                    pageSize,
                    sort,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/orders",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "statuses",
                            mapper: {
                                serializedName: "statuses",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.OrderHistoryList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.OrderHistoryList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get total number of orders
     *
     * In the response header, the "x-total-count" indicates the total number of orders placed by a
     * specified user for a specified base store.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetCountOrdersForUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCountOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let statuses = (options && options.statuses !== undefined) ? options.statuses : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    statuses,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/orders",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "statuses",
                            mapper: {
                                serializedName: "statuses",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Post a order
     *
     * Authorizes the cart and places the order. The response contains the new order data.
     *
     * @param {string} cartId Cart code for logged in user, cart GUID for guest checkout
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2PlaceOrderOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    placeOrderWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let securityCode = (options && options.securityCode !== undefined) ? options.securityCode : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    securityCode,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/orders",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "securityCode",
                            mapper: {
                                serializedName: "securityCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        201: {
                            bodyMapper: Mappers.Order
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Order;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a order
     *
     * Returns specific order details based on a specific order code. The response contains detailed
     * order information.
     *
     * @param {string} code Order GUID (Globally Unique Identifier) or order CODE
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetOrderForUserByCodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getOrderForUserByCodeWithHttpOperationResponse(code, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    code,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/orders/{code}",
                    urlParameters: [
                        {
                            parameterPath: "code",
                            mapper: {
                                required: true,
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Order
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Order;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Changes customer's password
     *
     * Changes customer's password.
     *
     * @param {string} newParameter New password.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2ChangePasswordOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    changePasswordWithHttpOperationResponse(newParameter, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let old = (options && options.old !== undefined) ? options.old : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    old,
                    newParameter,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/password",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "old",
                            mapper: {
                                serializedName: "old",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "newParameter",
                            mapper: {
                                required: true,
                                serializedName: "new",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        201: {},
                        202: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get customer's credit card payment details list.
     *
     * Return customer's credit card payment details list.
     *
     * @param {boolean} saved Type of payment details.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetPaymentInfosOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPaymentInfosWithHttpOperationResponse(saved, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    saved,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "saved",
                            mapper: {
                                required: true,
                                serializedName: "saved",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PaymentDetailsList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PaymentDetailsList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get customer's credit card payment details.
     *
     * Returns a customer's credit card payment details for the specified paymentDetailsId.
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetPaymentDetailsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails/{paymentDetailsId}",
                    urlParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PaymentDetails
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PaymentDetails;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates existing customer's credit card payment info.
     *
     * Updates existing customer's credit card payment info based on the payment info ID. Attributes
     * not given in request will be defined again (set to null or default).
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {PaymentDetails} paymentDetails Payment details object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    putPaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    paymentDetails,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails/{paymentDetailsId}",
                    urlParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "paymentDetails",
                        mapper: Object.assign({}, Mappers.PaymentDetails, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete customer's credit card payment details.
     *
     * Removes a customer's credit card payment details based on a specified paymentDetailsId.
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    deletePaymentInfoWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails/{paymentDetailsId}",
                    urlParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates existing customer's credit card payment details.
     *
     * Updates an existing customer's credit card payment details based on the specified
     * paymentDetailsId. Only those attributes provided in the request will be updated.
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {PaymentDetails} paymentDetails Payment details object
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    updatePaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    paymentDetails,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails/{paymentDetailsId}",
                    urlParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "paymentDetails",
                        mapper: Object.assign({}, Mappers.PaymentDetails, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a voucher based on code
     *
     * Returns details of a single voucher that is specified by its voucher identification code.
     *
     * @param {string} code Voucher identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetVoucherByCodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getVoucherByCodeWithHttpOperationResponse(code, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    code,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/vouchers/{code}",
                    urlParameters: [
                        {
                            parameterPath: "code",
                            mapper: {
                                required: true,
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Voucher
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Voucher;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    getCardTypes(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCardTypesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCardTypesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCatalogs(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCatalogsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCatalogsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCatalog(catalogId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCatalogWithHttpOperationResponse(catalogId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCatalogWithHttpOperationResponse(catalogId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCatalogVersion(catalogId, catalogVersionId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCatalogVersionWithHttpOperationResponse(catalogId, catalogVersionId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCatalogVersionWithHttpOperationResponse(catalogId, catalogVersionId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCategories(catalogId, catalogVersionId, categoryId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCategoriesWithHttpOperationResponse(catalogId, catalogVersionId, categoryId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCategoriesWithHttpOperationResponse(catalogId, catalogVersionId, categoryId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getComponentByIdList(componentIdList, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getComponentByIdListWithHttpOperationResponse(componentIdList, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getComponentByIdListWithHttpOperationResponse(componentIdList, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getComponentById(componentId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getComponentByIdWithHttpOperationResponse(componentId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getComponentByIdWithHttpOperationResponse(componentId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPageData(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPageDataWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPageDataWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCurrencies(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCurrenciesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCurrenciesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAllCustomerGroups(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllCustomerGroupsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllCustomerGroupsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createNewCustomerGroupPrim(userGroup, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createNewCustomerGroupPrimWithHttpOperationResponse(userGroup, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createNewCustomerGroupPrimWithHttpOperationResponse(userGroup, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCustomerGroup(groupId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCustomerGroupWithHttpOperationResponse(groupId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCustomerGroupWithHttpOperationResponse(groupId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setUserListForCustomerGroupPrim(groupId, members, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setUserListForCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setUserListForCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    assignUserToCustomerGroupPrim(groupId, members, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.assignUserToCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.assignUserToCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeUsersFromCustomerGroup(groupId, userId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeUsersFromCustomerGroupWithHttpOperationResponse(groupId, userId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeUsersFromCustomerGroupWithHttpOperationResponse(groupId, userId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getDeliveryCountries(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getDeliveryCountriesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getDeliveryCountriesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    exportProducts(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.exportProductsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.exportProductsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    orderStatusFeed(timestamp, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.orderStatusFeedWithHttpOperationResponse(timestamp, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.orderStatusFeedWithHttpOperationResponse(timestamp, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    restorePassword(userId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.restorePasswordWithHttpOperationResponse(userId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.restorePasswordWithHttpOperationResponse(userId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getLanguages(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getLanguagesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getLanguagesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getOrder(code, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getOrderWithHttpOperationResponse(code, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getOrderWithHttpOperationResponse(code, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    expressUpdate(timestamp, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.expressUpdateWithHttpOperationResponse(timestamp, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.expressUpdateWithHttpOperationResponse(timestamp, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    searchProducts(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.searchProductsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.searchProductsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    countSearchProducts(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.countSearchProductsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.countSearchProductsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getSuggestions(term, max, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getSuggestionsWithHttpOperationResponse(term, max, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getSuggestionsWithHttpOperationResponse(term, max, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getProductByCode(productCode, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getProductByCodeWithHttpOperationResponse(productCode, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getProductByCodeWithHttpOperationResponse(productCode, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    exportProductReferences(productCode, referenceType, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.exportProductReferencesWithHttpOperationResponse(productCode, referenceType, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.exportProductReferencesWithHttpOperationResponse(productCode, referenceType, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getProductReviews(productCode, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getProductReviewsWithHttpOperationResponse(productCode, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getProductReviewsWithHttpOperationResponse(productCode, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createReviewPrim(productCode, review, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createReviewPrimWithHttpOperationResponse(productCode, review, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createReviewPrimWithHttpOperationResponse(productCode, review, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    searchProductStockByLocation(productCode, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.searchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.searchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    countSearchProductStockByLocation(productCode, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.countSearchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.countSearchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getStockData(baseSiteId, productCode, storeName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getStockDataWithHttpOperationResponse(baseSiteId, productCode, storeName, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getStockDataWithHttpOperationResponse(baseSiteId, productCode, storeName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPromotionsPrim(type, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPromotionsPrimWithHttpOperationResponse(type, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPromotionsPrimWithHttpOperationResponse(type, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPromotionByCode(code, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPromotionByCodeWithHttpOperationResponse(code, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPromotionByCodeWithHttpOperationResponse(code, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    locationSearch(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.locationSearchWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.locationSearchWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    countLocationSearch(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.countLocationSearchWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.countLocationSearchWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    locationDetails(storeId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.locationDetailsWithHttpOperationResponse(storeId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.locationDetailsWithHttpOperationResponse(storeId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getTitles(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getTitlesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getTitlesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    registerUserPrim(user, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.registerUserPrimWithHttpOperationResponse(user, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.registerUserPrimWithHttpOperationResponse(user, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getUser(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getUserWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getUserWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    putUserPrim(user, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.putUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.putUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deactivateUser(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deactivateUserWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deactivateUserWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    updateUserPrim(user, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAddresses(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAddressesWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAddressesWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createAddressPrim(address, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    verifyAddressPrim(address, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.verifyAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.verifyAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAddress(addressId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    putAddressPrim(addressId, address, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.putAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.putAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteAddress(addressId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    patchAddressPrim(addressId, address, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCarts(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartsWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartsWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createCart(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createCartWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createCartWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCart(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteCart(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteCartWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteCartWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createAndSetAddressPrim(address, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createAndSetAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createAndSetAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setCartDeliveryAddress(addressId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setCartDeliveryAddressWithHttpOperationResponse(addressId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setCartDeliveryAddressWithHttpOperationResponse(addressId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeCartDeliveryAddress(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeCartDeliveryAddressWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeCartDeliveryAddressWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    cloneSaveCart(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.cloneSaveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.cloneSaveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCartDeliveryMode(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setCartDeliveryMode(deliveryModeId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setCartDeliveryModeWithHttpOperationResponse(deliveryModeId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setCartDeliveryModeWithHttpOperationResponse(deliveryModeId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeDeliveryMode(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getSupportedDeliveryModes(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getSupportedDeliveryModesWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getSupportedDeliveryModesWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    guestLogin(email, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.guestLoginWithHttpOperationResponse(email, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.guestLoginWithHttpOperationResponse(email, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCartEntries(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartEntriesWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartEntriesWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    addCartEntryPrim(entry, userId, cartId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addCartEntryPrimWithHttpOperationResponse(entry, userId, cartId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addCartEntryPrimWithHttpOperationResponse(entry, userId, cartId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCartEntry(entryNumber, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setCartEntryPrim(entryNumber, entry, userId, cartId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeCartEntry(entryNumber, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    updateCartEntryPrim(entryNumber, entry, userId, cartId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    flagForDeletion(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.flagForDeletionWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.flagForDeletionWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    addPaymentDetailsPrim(paymentDetails, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addPaymentDetailsPrimWithHttpOperationResponse(paymentDetails, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addPaymentDetailsPrimWithHttpOperationResponse(paymentDetails, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setPaymentDetails(paymentDetailsId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPromotions(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPromotionsWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPromotionsWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    applyPromotion(promotionId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.applyPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.applyPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPromotion(promotionId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removePromotion(promotionId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removePromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removePromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    restoreSavedCart(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.restoreSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.restoreSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    saveCart(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.saveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.saveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getSavedCart(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getVouchers(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getVouchersWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getVouchersWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    applyVoucherForCart(voucherId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.applyVoucherForCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.applyVoucherForCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    releaseVoucherFromCart(voucherId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.releaseVoucherFromCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.releaseVoucherFromCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAllCustomerGroupsForCustomer(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllCustomerGroupsForCustomerWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllCustomerGroupsForCustomerWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    changeLogin(newLogin, password, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.changeLoginWithHttpOperationResponse(newLogin, password, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.changeLoginWithHttpOperationResponse(newLogin, password, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getOrdersForUser(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCountOrdersForUser(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCountOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCountOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    placeOrder(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.placeOrderWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.placeOrderWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getOrderForUserByCode(code, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getOrderForUserByCodeWithHttpOperationResponse(code, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getOrderForUserByCodeWithHttpOperationResponse(code, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    changePassword(newParameter, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.changePasswordWithHttpOperationResponse(newParameter, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.changePasswordWithHttpOperationResponse(newParameter, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPaymentInfos(saved, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPaymentInfosWithHttpOperationResponse(saved, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPaymentInfosWithHttpOperationResponse(saved, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPaymentDetails(paymentDetailsId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    putPaymentInfoPrim(paymentDetailsId, paymentDetails, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.putPaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.putPaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deletePaymentInfo(paymentDetailsId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deletePaymentInfoWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deletePaymentInfoWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    updatePaymentInfoPrim(paymentDetailsId, paymentDetails, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updatePaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updatePaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getVoucherByCode(code, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getVoucherByCodeWithHttpOperationResponse(code, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getVoucherByCodeWithHttpOperationResponse(code, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.CommerceWebservicesV2 = CommerceWebservicesV2;


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__await"] = __await;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/* harmony export (immutable) */ __webpack_exports__["__makeTemplateObject"] = __makeTemplateObject;
/* harmony export (immutable) */ __webpack_exports__["__importStar"] = __importStar;
/* harmony export (immutable) */ __webpack_exports__["__importDefault"] = __importDefault;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Defines values for PriceType.
 * Possible values include: 'BUY', 'FROM'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PriceType = <PriceType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var PriceType;
(function (PriceType) {
    PriceType["BUY"] = "BUY";
    PriceType["FROM"] = "FROM";
})(PriceType = exports.PriceType || (exports.PriceType = {}));
/**
 * Defines values for ImageType.
 * Possible values include: 'PRIMARY', 'GALLERY'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ImageType = <ImageType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var ImageType;
(function (ImageType) {
    ImageType["PRIMARY"] = "PRIMARY";
    ImageType["GALLERY"] = "GALLERY";
})(ImageType = exports.ImageType || (exports.ImageType = {}));
/**
 * Defines values for Fields.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields = <Fields>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields;
(function (Fields) {
    Fields["BASIC"] = "BASIC";
    Fields["DEFAULT"] = "DEFAULT";
    Fields["FULL"] = "FULL";
})(Fields = exports.Fields || (exports.Fields = {}));
/**
 * Defines values for Fields1.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields1 = <Fields1>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields1;
(function (Fields1) {
    Fields1["BASIC"] = "BASIC";
    Fields1["DEFAULT"] = "DEFAULT";
    Fields1["FULL"] = "FULL";
})(Fields1 = exports.Fields1 || (exports.Fields1 = {}));
/**
 * Defines values for Fields2.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields2 = <Fields2>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields2;
(function (Fields2) {
    Fields2["BASIC"] = "BASIC";
    Fields2["DEFAULT"] = "DEFAULT";
    Fields2["FULL"] = "FULL";
})(Fields2 = exports.Fields2 || (exports.Fields2 = {}));
/**
 * Defines values for Fields3.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields3 = <Fields3>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields3;
(function (Fields3) {
    Fields3["BASIC"] = "BASIC";
    Fields3["DEFAULT"] = "DEFAULT";
    Fields3["FULL"] = "FULL";
})(Fields3 = exports.Fields3 || (exports.Fields3 = {}));
/**
 * Defines values for Fields4.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields4 = <Fields4>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields4;
(function (Fields4) {
    Fields4["BASIC"] = "BASIC";
    Fields4["DEFAULT"] = "DEFAULT";
    Fields4["FULL"] = "FULL";
})(Fields4 = exports.Fields4 || (exports.Fields4 = {}));
/**
 * Defines values for Fields5.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields5 = <Fields5>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields5;
(function (Fields5) {
    Fields5["BASIC"] = "BASIC";
    Fields5["DEFAULT"] = "DEFAULT";
    Fields5["FULL"] = "FULL";
})(Fields5 = exports.Fields5 || (exports.Fields5 = {}));
/**
 * Defines values for Fields6.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields6 = <Fields6>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields6;
(function (Fields6) {
    Fields6["BASIC"] = "BASIC";
    Fields6["DEFAULT"] = "DEFAULT";
    Fields6["FULL"] = "FULL";
})(Fields6 = exports.Fields6 || (exports.Fields6 = {}));
/**
 * Defines values for PageType.
 * Possible values include: 'ContentPage', 'ProductPage', 'CategoryPage',
 * 'CatalogPage'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PageType = <PageType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var PageType;
(function (PageType) {
    PageType["ContentPage"] = "ContentPage";
    PageType["ProductPage"] = "ProductPage";
    PageType["CategoryPage"] = "CategoryPage";
    PageType["CatalogPage"] = "CatalogPage";
})(PageType = exports.PageType || (exports.PageType = {}));
/**
 * Defines values for Fields7.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields7 = <Fields7>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields7;
(function (Fields7) {
    Fields7["BASIC"] = "BASIC";
    Fields7["DEFAULT"] = "DEFAULT";
    Fields7["FULL"] = "FULL";
})(Fields7 = exports.Fields7 || (exports.Fields7 = {}));
/**
 * Defines values for Fields8.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields8 = <Fields8>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields8;
(function (Fields8) {
    Fields8["BASIC"] = "BASIC";
    Fields8["DEFAULT"] = "DEFAULT";
    Fields8["FULL"] = "FULL";
})(Fields8 = exports.Fields8 || (exports.Fields8 = {}));
/**
 * Defines values for Fields9.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields9 = <Fields9>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields9;
(function (Fields9) {
    Fields9["BASIC"] = "BASIC";
    Fields9["DEFAULT"] = "DEFAULT";
    Fields9["FULL"] = "FULL";
})(Fields9 = exports.Fields9 || (exports.Fields9 = {}));
/**
 * Defines values for Fields10.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields10 = <Fields10>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields10;
(function (Fields10) {
    Fields10["BASIC"] = "BASIC";
    Fields10["DEFAULT"] = "DEFAULT";
    Fields10["FULL"] = "FULL";
})(Fields10 = exports.Fields10 || (exports.Fields10 = {}));
/**
 * Defines values for Fields11.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields11 = <Fields11>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields11;
(function (Fields11) {
    Fields11["BASIC"] = "BASIC";
    Fields11["DEFAULT"] = "DEFAULT";
    Fields11["FULL"] = "FULL";
})(Fields11 = exports.Fields11 || (exports.Fields11 = {}));
/**
 * Defines values for Fields12.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields12 = <Fields12>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields12;
(function (Fields12) {
    Fields12["BASIC"] = "BASIC";
    Fields12["DEFAULT"] = "DEFAULT";
    Fields12["FULL"] = "FULL";
})(Fields12 = exports.Fields12 || (exports.Fields12 = {}));
/**
 * Defines values for Fields13.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields13 = <Fields13>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields13;
(function (Fields13) {
    Fields13["BASIC"] = "BASIC";
    Fields13["DEFAULT"] = "DEFAULT";
    Fields13["FULL"] = "FULL";
})(Fields13 = exports.Fields13 || (exports.Fields13 = {}));
/**
 * Defines values for Fields14.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields14 = <Fields14>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields14;
(function (Fields14) {
    Fields14["BASIC"] = "BASIC";
    Fields14["DEFAULT"] = "DEFAULT";
    Fields14["FULL"] = "FULL";
})(Fields14 = exports.Fields14 || (exports.Fields14 = {}));
/**
 * Defines values for Fields15.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields15 = <Fields15>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields15;
(function (Fields15) {
    Fields15["BASIC"] = "BASIC";
    Fields15["DEFAULT"] = "DEFAULT";
    Fields15["FULL"] = "FULL";
})(Fields15 = exports.Fields15 || (exports.Fields15 = {}));
/**
 * Defines values for Fields16.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields16 = <Fields16>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields16;
(function (Fields16) {
    Fields16["BASIC"] = "BASIC";
    Fields16["DEFAULT"] = "DEFAULT";
    Fields16["FULL"] = "FULL";
})(Fields16 = exports.Fields16 || (exports.Fields16 = {}));
/**
 * Defines values for SortEnum.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: SortEnum = <SortEnum>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var SortEnum;
(function (SortEnum) {
    SortEnum["BASIC"] = "BASIC";
    SortEnum["DEFAULT"] = "DEFAULT";
    SortEnum["FULL"] = "FULL";
})(SortEnum = exports.SortEnum || (exports.SortEnum = {}));
/**
 * Defines values for Fields17.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields17 = <Fields17>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields17;
(function (Fields17) {
    Fields17["BASIC"] = "BASIC";
    Fields17["DEFAULT"] = "DEFAULT";
    Fields17["FULL"] = "FULL";
})(Fields17 = exports.Fields17 || (exports.Fields17 = {}));
/**
 * Defines values for Fields18.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields18 = <Fields18>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields18;
(function (Fields18) {
    Fields18["BASIC"] = "BASIC";
    Fields18["DEFAULT"] = "DEFAULT";
    Fields18["FULL"] = "FULL";
})(Fields18 = exports.Fields18 || (exports.Fields18 = {}));
/**
 * Defines values for Fields19.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields19 = <Fields19>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields19;
(function (Fields19) {
    Fields19["BASIC"] = "BASIC";
    Fields19["DEFAULT"] = "DEFAULT";
    Fields19["FULL"] = "FULL";
})(Fields19 = exports.Fields19 || (exports.Fields19 = {}));
/**
 * Defines values for Fields20.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields20 = <Fields20>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields20;
(function (Fields20) {
    Fields20["BASIC"] = "BASIC";
    Fields20["DEFAULT"] = "DEFAULT";
    Fields20["FULL"] = "FULL";
})(Fields20 = exports.Fields20 || (exports.Fields20 = {}));
/**
 * Defines values for Fields21.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields21 = <Fields21>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields21;
(function (Fields21) {
    Fields21["BASIC"] = "BASIC";
    Fields21["DEFAULT"] = "DEFAULT";
    Fields21["FULL"] = "FULL";
})(Fields21 = exports.Fields21 || (exports.Fields21 = {}));
/**
 * Defines values for Fields22.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields22 = <Fields22>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields22;
(function (Fields22) {
    Fields22["BASIC"] = "BASIC";
    Fields22["DEFAULT"] = "DEFAULT";
    Fields22["FULL"] = "FULL";
})(Fields22 = exports.Fields22 || (exports.Fields22 = {}));
/**
 * Defines values for Fields23.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields23 = <Fields23>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields23;
(function (Fields23) {
    Fields23["BASIC"] = "BASIC";
    Fields23["DEFAULT"] = "DEFAULT";
    Fields23["FULL"] = "FULL";
})(Fields23 = exports.Fields23 || (exports.Fields23 = {}));
/**
 * Defines values for Fields24.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields24 = <Fields24>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields24;
(function (Fields24) {
    Fields24["BASIC"] = "BASIC";
    Fields24["DEFAULT"] = "DEFAULT";
    Fields24["FULL"] = "FULL";
})(Fields24 = exports.Fields24 || (exports.Fields24 = {}));
/**
 * Defines values for Fields25.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields25 = <Fields25>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields25;
(function (Fields25) {
    Fields25["BASIC"] = "BASIC";
    Fields25["DEFAULT"] = "DEFAULT";
    Fields25["FULL"] = "FULL";
})(Fields25 = exports.Fields25 || (exports.Fields25 = {}));
/**
 * Defines values for Fields26.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields26 = <Fields26>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields26;
(function (Fields26) {
    Fields26["BASIC"] = "BASIC";
    Fields26["DEFAULT"] = "DEFAULT";
    Fields26["FULL"] = "FULL";
})(Fields26 = exports.Fields26 || (exports.Fields26 = {}));
/**
 * Defines values for Fields27.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields27 = <Fields27>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields27;
(function (Fields27) {
    Fields27["BASIC"] = "BASIC";
    Fields27["DEFAULT"] = "DEFAULT";
    Fields27["FULL"] = "FULL";
})(Fields27 = exports.Fields27 || (exports.Fields27 = {}));
/**
 * Defines values for Fields28.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields28 = <Fields28>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields28;
(function (Fields28) {
    Fields28["BASIC"] = "BASIC";
    Fields28["DEFAULT"] = "DEFAULT";
    Fields28["FULL"] = "FULL";
})(Fields28 = exports.Fields28 || (exports.Fields28 = {}));
/**
 * Defines values for Fields29.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields29 = <Fields29>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields29;
(function (Fields29) {
    Fields29["BASIC"] = "BASIC";
    Fields29["DEFAULT"] = "DEFAULT";
    Fields29["FULL"] = "FULL";
})(Fields29 = exports.Fields29 || (exports.Fields29 = {}));
/**
 * Defines values for Fields30.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields30 = <Fields30>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields30;
(function (Fields30) {
    Fields30["BASIC"] = "BASIC";
    Fields30["DEFAULT"] = "DEFAULT";
    Fields30["FULL"] = "FULL";
})(Fields30 = exports.Fields30 || (exports.Fields30 = {}));
/**
 * Defines values for Fields31.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields31 = <Fields31>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields31;
(function (Fields31) {
    Fields31["BASIC"] = "BASIC";
    Fields31["DEFAULT"] = "DEFAULT";
    Fields31["FULL"] = "FULL";
})(Fields31 = exports.Fields31 || (exports.Fields31 = {}));
/**
 * Defines values for Fields32.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields32 = <Fields32>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields32;
(function (Fields32) {
    Fields32["BASIC"] = "BASIC";
    Fields32["DEFAULT"] = "DEFAULT";
    Fields32["FULL"] = "FULL";
})(Fields32 = exports.Fields32 || (exports.Fields32 = {}));
/**
 * Defines values for Fields33.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields33 = <Fields33>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields33;
(function (Fields33) {
    Fields33["BASIC"] = "BASIC";
    Fields33["DEFAULT"] = "DEFAULT";
    Fields33["FULL"] = "FULL";
})(Fields33 = exports.Fields33 || (exports.Fields33 = {}));
/**
 * Defines values for Fields34.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields34 = <Fields34>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields34;
(function (Fields34) {
    Fields34["BASIC"] = "BASIC";
    Fields34["DEFAULT"] = "DEFAULT";
    Fields34["FULL"] = "FULL";
})(Fields34 = exports.Fields34 || (exports.Fields34 = {}));
/**
 * Defines values for Fields35.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields35 = <Fields35>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields35;
(function (Fields35) {
    Fields35["BASIC"] = "BASIC";
    Fields35["DEFAULT"] = "DEFAULT";
    Fields35["FULL"] = "FULL";
})(Fields35 = exports.Fields35 || (exports.Fields35 = {}));
/**
 * Defines values for Fields36.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields36 = <Fields36>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields36;
(function (Fields36) {
    Fields36["BASIC"] = "BASIC";
    Fields36["DEFAULT"] = "DEFAULT";
    Fields36["FULL"] = "FULL";
})(Fields36 = exports.Fields36 || (exports.Fields36 = {}));
/**
 * Defines values for Fields37.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields37 = <Fields37>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields37;
(function (Fields37) {
    Fields37["BASIC"] = "BASIC";
    Fields37["DEFAULT"] = "DEFAULT";
    Fields37["FULL"] = "FULL";
})(Fields37 = exports.Fields37 || (exports.Fields37 = {}));
/**
 * Defines values for Fields38.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields38 = <Fields38>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields38;
(function (Fields38) {
    Fields38["BASIC"] = "BASIC";
    Fields38["DEFAULT"] = "DEFAULT";
    Fields38["FULL"] = "FULL";
})(Fields38 = exports.Fields38 || (exports.Fields38 = {}));
/**
 * Defines values for Fields39.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields39 = <Fields39>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields39;
(function (Fields39) {
    Fields39["BASIC"] = "BASIC";
    Fields39["DEFAULT"] = "DEFAULT";
    Fields39["FULL"] = "FULL";
})(Fields39 = exports.Fields39 || (exports.Fields39 = {}));
/**
 * Defines values for Fields40.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields40 = <Fields40>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields40;
(function (Fields40) {
    Fields40["BASIC"] = "BASIC";
    Fields40["DEFAULT"] = "DEFAULT";
    Fields40["FULL"] = "FULL";
})(Fields40 = exports.Fields40 || (exports.Fields40 = {}));
/**
 * Defines values for Fields41.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields41 = <Fields41>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields41;
(function (Fields41) {
    Fields41["BASIC"] = "BASIC";
    Fields41["DEFAULT"] = "DEFAULT";
    Fields41["FULL"] = "FULL";
})(Fields41 = exports.Fields41 || (exports.Fields41 = {}));
/**
 * Defines values for Fields42.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields42 = <Fields42>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields42;
(function (Fields42) {
    Fields42["BASIC"] = "BASIC";
    Fields42["DEFAULT"] = "DEFAULT";
    Fields42["FULL"] = "FULL";
})(Fields42 = exports.Fields42 || (exports.Fields42 = {}));
/**
 * Defines values for Fields43.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields43 = <Fields43>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields43;
(function (Fields43) {
    Fields43["BASIC"] = "BASIC";
    Fields43["DEFAULT"] = "DEFAULT";
    Fields43["FULL"] = "FULL";
})(Fields43 = exports.Fields43 || (exports.Fields43 = {}));
/**
 * Defines values for Fields44.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields44 = <Fields44>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields44;
(function (Fields44) {
    Fields44["BASIC"] = "BASIC";
    Fields44["DEFAULT"] = "DEFAULT";
    Fields44["FULL"] = "FULL";
})(Fields44 = exports.Fields44 || (exports.Fields44 = {}));
/**
 * Defines values for Fields45.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields45 = <Fields45>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields45;
(function (Fields45) {
    Fields45["BASIC"] = "BASIC";
    Fields45["DEFAULT"] = "DEFAULT";
    Fields45["FULL"] = "FULL";
})(Fields45 = exports.Fields45 || (exports.Fields45 = {}));
/**
 * Defines values for Fields46.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields46 = <Fields46>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields46;
(function (Fields46) {
    Fields46["BASIC"] = "BASIC";
    Fields46["DEFAULT"] = "DEFAULT";
    Fields46["FULL"] = "FULL";
})(Fields46 = exports.Fields46 || (exports.Fields46 = {}));
/**
 * Defines values for Fields47.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields47 = <Fields47>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields47;
(function (Fields47) {
    Fields47["BASIC"] = "BASIC";
    Fields47["DEFAULT"] = "DEFAULT";
    Fields47["FULL"] = "FULL";
})(Fields47 = exports.Fields47 || (exports.Fields47 = {}));
/**
 * Defines values for Fields48.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields48 = <Fields48>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields48;
(function (Fields48) {
    Fields48["BASIC"] = "BASIC";
    Fields48["DEFAULT"] = "DEFAULT";
    Fields48["FULL"] = "FULL";
})(Fields48 = exports.Fields48 || (exports.Fields48 = {}));
/**
 * Defines values for Fields49.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields49 = <Fields49>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields49;
(function (Fields49) {
    Fields49["BASIC"] = "BASIC";
    Fields49["DEFAULT"] = "DEFAULT";
    Fields49["FULL"] = "FULL";
})(Fields49 = exports.Fields49 || (exports.Fields49 = {}));
/**
 * Defines values for Fields50.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields50 = <Fields50>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields50;
(function (Fields50) {
    Fields50["BASIC"] = "BASIC";
    Fields50["DEFAULT"] = "DEFAULT";
    Fields50["FULL"] = "FULL";
})(Fields50 = exports.Fields50 || (exports.Fields50 = {}));
/**
 * Defines values for Fields51.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields51 = <Fields51>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields51;
(function (Fields51) {
    Fields51["BASIC"] = "BASIC";
    Fields51["DEFAULT"] = "DEFAULT";
    Fields51["FULL"] = "FULL";
})(Fields51 = exports.Fields51 || (exports.Fields51 = {}));
/**
 * Defines values for Fields52.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields52 = <Fields52>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields52;
(function (Fields52) {
    Fields52["BASIC"] = "BASIC";
    Fields52["DEFAULT"] = "DEFAULT";
    Fields52["FULL"] = "FULL";
})(Fields52 = exports.Fields52 || (exports.Fields52 = {}));
/**
 * Defines values for Fields53.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields53 = <Fields53>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields53;
(function (Fields53) {
    Fields53["BASIC"] = "BASIC";
    Fields53["DEFAULT"] = "DEFAULT";
    Fields53["FULL"] = "FULL";
})(Fields53 = exports.Fields53 || (exports.Fields53 = {}));
/**
 * Defines values for Fields54.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields54 = <Fields54>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields54;
(function (Fields54) {
    Fields54["BASIC"] = "BASIC";
    Fields54["DEFAULT"] = "DEFAULT";
    Fields54["FULL"] = "FULL";
})(Fields54 = exports.Fields54 || (exports.Fields54 = {}));
/**
 * Defines values for Fields55.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields55 = <Fields55>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields55;
(function (Fields55) {
    Fields55["BASIC"] = "BASIC";
    Fields55["DEFAULT"] = "DEFAULT";
    Fields55["FULL"] = "FULL";
})(Fields55 = exports.Fields55 || (exports.Fields55 = {}));
/**
 * Defines values for Fields56.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields56 = <Fields56>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields56;
(function (Fields56) {
    Fields56["BASIC"] = "BASIC";
    Fields56["DEFAULT"] = "DEFAULT";
    Fields56["FULL"] = "FULL";
})(Fields56 = exports.Fields56 || (exports.Fields56 = {}));
/**
 * Defines values for Fields57.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields57 = <Fields57>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields57;
(function (Fields57) {
    Fields57["BASIC"] = "BASIC";
    Fields57["DEFAULT"] = "DEFAULT";
    Fields57["FULL"] = "FULL";
})(Fields57 = exports.Fields57 || (exports.Fields57 = {}));
/**
 * Defines values for Fields58.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields58 = <Fields58>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields58;
(function (Fields58) {
    Fields58["BASIC"] = "BASIC";
    Fields58["DEFAULT"] = "DEFAULT";
    Fields58["FULL"] = "FULL";
})(Fields58 = exports.Fields58 || (exports.Fields58 = {}));
/**
 * Defines values for Fields59.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields59 = <Fields59>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields59;
(function (Fields59) {
    Fields59["BASIC"] = "BASIC";
    Fields59["DEFAULT"] = "DEFAULT";
    Fields59["FULL"] = "FULL";
})(Fields59 = exports.Fields59 || (exports.Fields59 = {}));
/**
 * Defines values for Fields60.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields60 = <Fields60>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields60;
(function (Fields60) {
    Fields60["BASIC"] = "BASIC";
    Fields60["DEFAULT"] = "DEFAULT";
    Fields60["FULL"] = "FULL";
})(Fields60 = exports.Fields60 || (exports.Fields60 = {}));
/**
 * Defines values for Fields61.
 * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Fields61 = <Fields61>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Fields61;
(function (Fields61) {
    Fields61["BASIC"] = "BASIC";
    Fields61["DEFAULT"] = "DEFAULT";
    Fields61["FULL"] = "FULL";
})(Fields61 = exports.Fields61 || (exports.Fields61 = {}));
/**
 * Defines values for Type.
 * Possible values include: 'all', 'product', 'order'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: Type = <Type>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
var Type;
(function (Type) {
    Type["All"] = "all";
    Type["Product"] = "product";
    Type["Order"] = "order";
})(Type = exports.Type || (exports.Type = {}));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Country = {
    serializedName: "Country",
    type: {
        name: "Composite",
        className: "Country",
        modelProperties: {
            isocode: {
                serializedName: "isocode",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Region = {
    serializedName: "Region",
    type: {
        name: "Composite",
        className: "Region",
        modelProperties: {
            countryIso: {
                serializedName: "countryIso",
                type: {
                    name: "String"
                }
            },
            isocode: {
                serializedName: "isocode",
                type: {
                    name: "String"
                }
            },
            isocodeShort: {
                serializedName: "isocodeShort",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Address = {
    serializedName: "Address",
    type: {
        name: "Composite",
        className: "Address",
        modelProperties: {
            companyName: {
                serializedName: "companyName",
                type: {
                    name: "String"
                }
            },
            country: {
                serializedName: "country",
                type: {
                    name: "Composite",
                    className: "Country"
                }
            },
            defaultAddress: {
                serializedName: "defaultAddress",
                type: {
                    name: "Boolean"
                }
            },
            email: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            firstName: {
                serializedName: "firstName",
                type: {
                    name: "String"
                }
            },
            formattedAddress: {
                serializedName: "formattedAddress",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            lastName: {
                serializedName: "lastName",
                type: {
                    name: "String"
                }
            },
            line1: {
                serializedName: "line1",
                type: {
                    name: "String"
                }
            },
            line2: {
                serializedName: "line2",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            },
            postalCode: {
                serializedName: "postalCode",
                type: {
                    name: "String"
                }
            },
            region: {
                serializedName: "region",
                type: {
                    name: "Composite",
                    className: "Region"
                }
            },
            shippingAddress: {
                serializedName: "shippingAddress",
                type: {
                    name: "Boolean"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            titleCode: {
                serializedName: "titleCode",
                type: {
                    name: "String"
                }
            },
            town: {
                serializedName: "town",
                type: {
                    name: "String"
                }
            },
            visibleInAddressBook: {
                serializedName: "visibleInAddressBook",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.AddressList = {
    serializedName: "AddressList",
    type: {
        name: "Composite",
        className: "AddressList",
        modelProperties: {
            addresses: {
                serializedName: "addresses",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "AddressElementType",
                        type: {
                            name: "Composite",
                            className: "Address"
                        }
                    }
                }
            }
        }
    }
};
exports.ErrorModel = {
    serializedName: "error",
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            },
            subject: {
                serializedName: "subject",
                type: {
                    name: "String"
                }
            },
            subjectType: {
                serializedName: "subjectType",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ErrorList = {
    serializedName: "errorList",
    type: {
        name: "Composite",
        className: "ErrorList",
        modelProperties: {
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ErrorModelElementType",
                        type: {
                            name: "Composite",
                            className: "ErrorModel"
                        }
                    }
                }
            }
        }
    }
};
exports.AddressValidation = {
    serializedName: "AddressValidation",
    type: {
        name: "Composite",
        className: "AddressValidation",
        modelProperties: {
            decision: {
                serializedName: "decision",
                type: {
                    name: "String"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Composite",
                    className: "ErrorList"
                }
            },
            suggestedAddresses: {
                serializedName: "suggestedAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "AddressElementType",
                        type: {
                            name: "Composite",
                            className: "Address"
                        }
                    }
                }
            }
        }
    }
};
exports.Price = {
    serializedName: "Price",
    type: {
        name: "Composite",
        className: "Price",
        modelProperties: {
            currencyIso: {
                serializedName: "currencyIso",
                type: {
                    name: "String"
                }
            },
            formattedValue: {
                serializedName: "formattedValue",
                type: {
                    name: "String"
                }
            },
            maxQuantity: {
                serializedName: "maxQuantity",
                type: {
                    name: "Number"
                }
            },
            minQuantity: {
                serializedName: "minQuantity",
                type: {
                    name: "Number"
                }
            },
            priceType: {
                serializedName: "priceType",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.Stock = {
    serializedName: "Stock",
    type: {
        name: "Composite",
        className: "Stock",
        modelProperties: {
            stockLevel: {
                serializedName: "stockLevel",
                type: {
                    name: "Number"
                }
            },
            stockLevelStatus: {
                serializedName: "stockLevelStatus",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Image = {
    serializedName: "Image",
    type: {
        name: "Composite",
        className: "Image",
        modelProperties: {
            altText: {
                serializedName: "altText",
                type: {
                    name: "String"
                }
            },
            format: {
                serializedName: "format",
                type: {
                    name: "String"
                }
            },
            galleryIndex: {
                serializedName: "galleryIndex",
                type: {
                    name: "Number"
                }
            },
            imageType: {
                serializedName: "imageType",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.VariantOptionQualifier = {
    serializedName: "VariantOptionQualifier",
    type: {
        name: "Composite",
        className: "VariantOptionQualifier",
        modelProperties: {
            image: {
                serializedName: "image",
                type: {
                    name: "Composite",
                    className: "Image"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            qualifier: {
                serializedName: "qualifier",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.VariantOption = {
    serializedName: "VariantOption",
    type: {
        name: "Composite",
        className: "VariantOption",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            priceData: {
                serializedName: "priceData",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            stock: {
                serializedName: "stock",
                type: {
                    name: "Composite",
                    className: "Stock"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            variantOptionQualifiers: {
                serializedName: "variantOptionQualifiers",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VariantOptionQualifierElementType",
                        type: {
                            name: "Composite",
                            className: "VariantOptionQualifier"
                        }
                    }
                }
            }
        }
    }
};
exports.BaseOption = {
    serializedName: "BaseOption",
    type: {
        name: "Composite",
        className: "BaseOption",
        modelProperties: {
            options: {
                serializedName: "options",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VariantOptionElementType",
                        type: {
                            name: "Composite",
                            className: "VariantOption"
                        }
                    }
                }
            },
            selected: {
                serializedName: "selected",
                type: {
                    name: "Composite",
                    className: "VariantOption"
                }
            },
            variantType: {
                serializedName: "variantType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.SearchQuery = {
    serializedName: "SearchQuery",
    type: {
        name: "Composite",
        className: "SearchQuery",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.SearchState = {
    serializedName: "SearchState",
    type: {
        name: "Composite",
        className: "SearchState",
        modelProperties: {
            query: {
                serializedName: "query",
                type: {
                    name: "Composite",
                    className: "SearchQuery"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Breadcrumb = {
    serializedName: "Breadcrumb",
    type: {
        name: "Composite",
        className: "Breadcrumb",
        modelProperties: {
            facetCode: {
                serializedName: "facetCode",
                type: {
                    name: "String"
                }
            },
            facetName: {
                serializedName: "facetName",
                type: {
                    name: "String"
                }
            },
            facetValueCode: {
                serializedName: "facetValueCode",
                type: {
                    name: "String"
                }
            },
            facetValueName: {
                serializedName: "facetValueName",
                type: {
                    name: "String"
                }
            },
            removeQuery: {
                serializedName: "removeQuery",
                type: {
                    name: "Composite",
                    className: "SearchState"
                }
            },
            truncateQuery: {
                serializedName: "truncateQuery",
                type: {
                    name: "Composite",
                    className: "SearchState"
                }
            }
        }
    }
};
exports.Component = {
    serializedName: "Component",
    type: {
        name: "Composite",
        className: "Component",
        modelProperties: {
            modifiedtime: {
                serializedName: "modifiedtime",
                type: {
                    name: "DateTime"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            otherProperties: {
                serializedName: "otherProperties",
                type: {
                    name: "Object"
                }
            },
            typeCode: {
                serializedName: "typeCode",
                type: {
                    name: "String"
                }
            },
            uid: {
                serializedName: "uid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ComponentList = {
    serializedName: "ComponentList",
    type: {
        name: "Composite",
        className: "ComponentList",
        modelProperties: {
            component: {
                serializedName: "component",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ComponentElementType",
                        type: {
                            name: "Composite",
                            className: "Component"
                        }
                    }
                }
            }
        }
    }
};
exports.ContentSlot = {
    serializedName: "ContentSlot",
    type: {
        name: "Composite",
        className: "ContentSlot",
        modelProperties: {
            components: {
                serializedName: "components",
                type: {
                    name: "Composite",
                    className: "ComponentList"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            position: {
                serializedName: "position",
                type: {
                    name: "String"
                }
            },
            slotId: {
                serializedName: "slotId",
                type: {
                    name: "String"
                }
            },
            slotShared: {
                serializedName: "slotShared",
                type: {
                    name: "Boolean"
                }
            },
            slotStatus: {
                serializedName: "slotStatus",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ContentSlotList = {
    serializedName: "ContentSlotList",
    type: {
        name: "Composite",
        className: "ContentSlotList",
        modelProperties: {
            contentSlot: {
                serializedName: "contentSlot",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ContentSlotElementType",
                        type: {
                            name: "Composite",
                            className: "ContentSlot"
                        }
                    }
                }
            }
        }
    }
};
exports.CMSPage = {
    serializedName: "CMSPage",
    type: {
        name: "Composite",
        className: "CMSPage",
        modelProperties: {
            contentSlots: {
                serializedName: "contentSlots",
                type: {
                    name: "Composite",
                    className: "ContentSlotList"
                }
            },
            defaultPage: {
                serializedName: "defaultPage",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            template: {
                serializedName: "template",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            typeCode: {
                serializedName: "typeCode",
                type: {
                    name: "String"
                }
            },
            uid: {
                serializedName: "uid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CardType = {
    serializedName: "CardType",
    type: {
        name: "Composite",
        className: "CardType",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CardTypeList = {
    serializedName: "CardTypeList",
    type: {
        name: "Composite",
        className: "CardTypeList",
        modelProperties: {
            cardTypes: {
                serializedName: "cardTypes",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CardTypeElementType",
                        type: {
                            name: "Composite",
                            className: "CardType"
                        }
                    }
                }
            }
        }
    }
};
exports.PromotionOrderEntryConsumed = {
    serializedName: "PromotionOrderEntryConsumed",
    type: {
        name: "Composite",
        className: "PromotionOrderEntryConsumed",
        modelProperties: {
            adjustedUnitPrice: {
                serializedName: "adjustedUnitPrice",
                type: {
                    name: "Number"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            orderEntryNumber: {
                serializedName: "orderEntryNumber",
                type: {
                    name: "Number"
                }
            },
            quantity: {
                serializedName: "quantity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.PromotionRestriction = {
    serializedName: "PromotionRestriction",
    type: {
        name: "Composite",
        className: "PromotionRestriction",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            restrictionType: {
                serializedName: "restrictionType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Promotion = {
    serializedName: "Promotion",
    type: {
        name: "Composite",
        className: "Promotion",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            couldFireMessages: {
                serializedName: "couldFireMessages",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            endDate: {
                serializedName: "endDate",
                type: {
                    name: "DateTime"
                }
            },
            firedMessages: {
                serializedName: "firedMessages",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            productBanner: {
                serializedName: "productBanner",
                type: {
                    name: "Composite",
                    className: "Image"
                }
            },
            promotionGroup: {
                serializedName: "promotionGroup",
                type: {
                    name: "String"
                }
            },
            promotionType: {
                serializedName: "promotionType",
                type: {
                    name: "String"
                }
            },
            restrictions: {
                serializedName: "restrictions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionRestrictionElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionRestriction"
                        }
                    }
                }
            },
            startDate: {
                serializedName: "startDate",
                type: {
                    name: "DateTime"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PromotionResult = {
    serializedName: "PromotionResult",
    type: {
        name: "Composite",
        className: "PromotionResult",
        modelProperties: {
            consumedEntries: {
                serializedName: "consumedEntries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionOrderEntryConsumedElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionOrderEntryConsumed"
                        }
                    }
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            promotion: {
                serializedName: "promotion",
                type: {
                    name: "Composite",
                    className: "Promotion"
                }
            }
        }
    }
};
exports.Currency = {
    serializedName: "Currency",
    type: {
        name: "Composite",
        className: "Currency",
        modelProperties: {
            active: {
                serializedName: "active",
                type: {
                    name: "Boolean"
                }
            },
            isocode: {
                serializedName: "isocode",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            symbol: {
                serializedName: "symbol",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Voucher = {
    serializedName: "Voucher",
    type: {
        name: "Composite",
        className: "Voucher",
        modelProperties: {
            appliedValue: {
                serializedName: "appliedValue",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            currency: {
                serializedName: "currency",
                type: {
                    name: "Composite",
                    className: "Currency"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            freeShipping: {
                serializedName: "freeShipping",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            },
            valueFormatted: {
                serializedName: "valueFormatted",
                type: {
                    name: "String"
                }
            },
            valueString: {
                serializedName: "valueString",
                type: {
                    name: "String"
                }
            },
            voucherCode: {
                serializedName: "voucherCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.DeliveryMode = {
    serializedName: "DeliveryMode",
    type: {
        name: "Composite",
        className: "DeliveryMode",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            deliveryCost: {
                serializedName: "deliveryCost",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.GeoPoint = {
    serializedName: "GeoPoint",
    type: {
        name: "Composite",
        className: "GeoPoint",
        modelProperties: {
            latitude: {
                serializedName: "latitude",
                type: {
                    name: "Number"
                }
            },
            longitude: {
                serializedName: "longitude",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.Time = {
    serializedName: "Time",
    type: {
        name: "Composite",
        className: "Time",
        modelProperties: {
            formattedHour: {
                serializedName: "formattedHour",
                type: {
                    name: "String"
                }
            },
            hour: {
                serializedName: "hour",
                type: {
                    name: "ByteArray"
                }
            },
            minute: {
                serializedName: "minute",
                type: {
                    name: "ByteArray"
                }
            }
        }
    }
};
exports.SpecialOpeningDay = {
    serializedName: "SpecialOpeningDay",
    type: {
        name: "Composite",
        className: "SpecialOpeningDay",
        modelProperties: {
            closed: {
                serializedName: "closed",
                type: {
                    name: "Boolean"
                }
            },
            closingTime: {
                serializedName: "closingTime",
                type: {
                    name: "Composite",
                    className: "Time"
                }
            },
            comment: {
                serializedName: "comment",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTime"
                }
            },
            formattedDate: {
                serializedName: "formattedDate",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            openingTime: {
                serializedName: "openingTime",
                type: {
                    name: "Composite",
                    className: "Time"
                }
            }
        }
    }
};
exports.WeekdayOpeningDay = {
    serializedName: "WeekdayOpeningDay",
    type: {
        name: "Composite",
        className: "WeekdayOpeningDay",
        modelProperties: {
            closed: {
                serializedName: "closed",
                type: {
                    name: "Boolean"
                }
            },
            closingTime: {
                serializedName: "closingTime",
                type: {
                    name: "Composite",
                    className: "Time"
                }
            },
            openingTime: {
                serializedName: "openingTime",
                type: {
                    name: "Composite",
                    className: "Time"
                }
            },
            weekDay: {
                serializedName: "weekDay",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.OpeningSchedule = {
    serializedName: "OpeningSchedule",
    type: {
        name: "Composite",
        className: "OpeningSchedule",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            specialDayOpeningList: {
                serializedName: "specialDayOpeningList",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "SpecialOpeningDayElementType",
                        type: {
                            name: "Composite",
                            className: "SpecialOpeningDay"
                        }
                    }
                }
            },
            weekDayOpeningList: {
                serializedName: "weekDayOpeningList",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "WeekdayOpeningDayElementType",
                        type: {
                            name: "Composite",
                            className: "WeekdayOpeningDay"
                        }
                    }
                }
            }
        }
    }
};
exports.PointOfService = {
    serializedName: "PointOfService",
    type: {
        name: "Composite",
        className: "PointOfService",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            distanceKm: {
                serializedName: "distanceKm",
                type: {
                    name: "Number"
                }
            },
            features: {
                serializedName: "features",
                type: {
                    name: "Dictionary",
                    value: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            formattedDistance: {
                serializedName: "formattedDistance",
                type: {
                    name: "String"
                }
            },
            geoPoint: {
                serializedName: "geoPoint",
                type: {
                    name: "Composite",
                    className: "GeoPoint"
                }
            },
            mapIcon: {
                serializedName: "mapIcon",
                type: {
                    name: "Composite",
                    className: "Image"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            openingHours: {
                serializedName: "openingHours",
                type: {
                    name: "Composite",
                    className: "OpeningSchedule"
                }
            },
            storeContent: {
                serializedName: "storeContent",
                type: {
                    name: "String"
                }
            },
            storeImages: {
                serializedName: "storeImages",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ImageElementType",
                        type: {
                            name: "Composite",
                            className: "Image"
                        }
                    }
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Category = {
    serializedName: "Category",
    type: {
        name: "Composite",
        className: "Category",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            image: {
                serializedName: "image",
                type: {
                    name: "Composite",
                    className: "Image"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.FeatureUnit = {
    serializedName: "FeatureUnit",
    type: {
        name: "Composite",
        className: "FeatureUnit",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            symbol: {
                serializedName: "symbol",
                type: {
                    name: "String"
                }
            },
            unitType: {
                serializedName: "unitType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.FeatureValue = {
    serializedName: "FeatureValue",
    type: {
        name: "Composite",
        className: "FeatureValue",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Feature = {
    serializedName: "Feature",
    type: {
        name: "Composite",
        className: "Feature",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            comparable: {
                serializedName: "comparable",
                type: {
                    name: "Boolean"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            featureUnit: {
                serializedName: "featureUnit",
                type: {
                    name: "Composite",
                    className: "FeatureUnit"
                }
            },
            featureValues: {
                serializedName: "featureValues",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "FeatureValueElementType",
                        type: {
                            name: "Composite",
                            className: "FeatureValue"
                        }
                    }
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            range: {
                serializedName: "range",
                type: {
                    name: "Boolean"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Classification = {
    serializedName: "Classification",
    type: {
        name: "Composite",
        className: "Classification",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            features: {
                serializedName: "features",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "FeatureElementType",
                        type: {
                            name: "Composite",
                            className: "Feature"
                        }
                    }
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.FutureStock = {
    serializedName: "FutureStock",
    type: {
        name: "Composite",
        className: "FutureStock",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTime"
                }
            },
            formattedDate: {
                serializedName: "formattedDate",
                type: {
                    name: "String"
                }
            },
            stock: {
                serializedName: "stock",
                type: {
                    name: "Composite",
                    className: "Stock"
                }
            }
        }
    }
};
exports.PriceRange = {
    serializedName: "PriceRange",
    type: {
        name: "Composite",
        className: "PriceRange",
        modelProperties: {
            maxPrice: {
                serializedName: "maxPrice",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            minPrice: {
                serializedName: "minPrice",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            }
        }
    }
};
exports.ProductReference = {
    serializedName: "ProductReference",
    type: {
        name: "Composite",
        className: "ProductReference",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            preselected: {
                serializedName: "preselected",
                type: {
                    name: "Boolean"
                }
            },
            quantity: {
                serializedName: "quantity",
                type: {
                    name: "Number"
                }
            },
            referenceType: {
                serializedName: "referenceType",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "Composite",
                    className: "Product"
                }
            }
        }
    }
};
exports.Language = {
    serializedName: "Language",
    type: {
        name: "Composite",
        className: "Language",
        modelProperties: {
            active: {
                serializedName: "active",
                type: {
                    name: "Boolean"
                }
            },
            isocode: {
                serializedName: "isocode",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            nativeName: {
                serializedName: "nativeName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.User = {
    serializedName: "User",
    type: {
        name: "Composite",
        className: "User",
        modelProperties: {
            currency: {
                serializedName: "currency",
                type: {
                    name: "Composite",
                    className: "Currency"
                }
            },
            customerId: {
                serializedName: "customerId",
                type: {
                    name: "String"
                }
            },
            deactivationDate: {
                serializedName: "deactivationDate",
                type: {
                    name: "DateTime"
                }
            },
            defaultAddress: {
                serializedName: "defaultAddress",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            displayUid: {
                serializedName: "displayUid",
                type: {
                    name: "String"
                }
            },
            firstName: {
                serializedName: "firstName",
                type: {
                    name: "String"
                }
            },
            language: {
                serializedName: "language",
                type: {
                    name: "Composite",
                    className: "Language"
                }
            },
            lastName: {
                serializedName: "lastName",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            titleCode: {
                serializedName: "titleCode",
                type: {
                    name: "String"
                }
            },
            uid: {
                serializedName: "uid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Review = {
    serializedName: "Review",
    type: {
        name: "Composite",
        className: "Review",
        modelProperties: {
            alias: {
                serializedName: "alias",
                type: {
                    name: "String"
                }
            },
            comment: {
                serializedName: "comment",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                type: {
                    name: "DateTime"
                }
            },
            headline: {
                serializedName: "headline",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            principal: {
                serializedName: "principal",
                type: {
                    name: "Composite",
                    className: "User"
                }
            },
            rating: {
                serializedName: "rating",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.VariantCategory = {
    serializedName: "VariantCategory",
    type: {
        name: "Composite",
        className: "VariantCategory",
        modelProperties: {
            hasImage: {
                serializedName: "hasImage",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.VariantValueCategory = {
    serializedName: "VariantValueCategory",
    type: {
        name: "Composite",
        className: "VariantValueCategory",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            sequence: {
                serializedName: "sequence",
                type: {
                    name: "Number"
                }
            },
            superCategories: {
                serializedName: "superCategories",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VariantCategoryElementType",
                        type: {
                            name: "Composite",
                            className: "VariantCategory"
                        }
                    }
                }
            }
        }
    }
};
exports.VariantMatrixElement = {
    serializedName: "VariantMatrixElement",
    type: {
        name: "Composite",
        className: "VariantMatrixElement",
        modelProperties: {
            elements: {
                serializedName: "elements",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VariantMatrixElementElementType",
                        type: {
                            name: "Composite",
                            className: "VariantMatrixElement"
                        }
                    }
                }
            },
            isLeaf: {
                serializedName: "isLeaf",
                type: {
                    name: "Boolean"
                }
            },
            parentVariantCategory: {
                serializedName: "parentVariantCategory",
                type: {
                    name: "Composite",
                    className: "VariantCategory"
                }
            },
            variantOption: {
                serializedName: "variantOption",
                type: {
                    name: "Composite",
                    className: "VariantOption"
                }
            },
            variantValueCategory: {
                serializedName: "variantValueCategory",
                type: {
                    name: "Composite",
                    className: "VariantValueCategory"
                }
            }
        }
    }
};
exports.Product = {
    serializedName: "Product",
    type: {
        name: "Composite",
        className: "Product",
        modelProperties: {
            availableForPickup: {
                serializedName: "availableForPickup",
                type: {
                    name: "Boolean"
                }
            },
            averageRating: {
                serializedName: "averageRating",
                type: {
                    name: "Number"
                }
            },
            baseOptions: {
                serializedName: "baseOptions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "BaseOptionElementType",
                        type: {
                            name: "Composite",
                            className: "BaseOption"
                        }
                    }
                }
            },
            baseProduct: {
                serializedName: "baseProduct",
                type: {
                    name: "String"
                }
            },
            categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CategoryElementType",
                        type: {
                            name: "Composite",
                            className: "Category"
                        }
                    }
                }
            },
            classifications: {
                serializedName: "classifications",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ClassificationElementType",
                        type: {
                            name: "Composite",
                            className: "Classification"
                        }
                    }
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            futureStocks: {
                serializedName: "futureStocks",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "FutureStockElementType",
                        type: {
                            name: "Composite",
                            className: "FutureStock"
                        }
                    }
                }
            },
            images: {
                serializedName: "images",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ImageElementType",
                        type: {
                            name: "Composite",
                            className: "Image"
                        }
                    }
                }
            },
            manufacturer: {
                serializedName: "manufacturer",
                type: {
                    name: "String"
                }
            },
            multidimensional: {
                serializedName: "multidimensional",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            numberOfReviews: {
                serializedName: "numberOfReviews",
                type: {
                    name: "Number"
                }
            },
            potentialPromotions: {
                serializedName: "potentialPromotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionElementType",
                        type: {
                            name: "Composite",
                            className: "Promotion"
                        }
                    }
                }
            },
            price: {
                serializedName: "price",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            priceRange: {
                serializedName: "priceRange",
                type: {
                    name: "Composite",
                    className: "PriceRange"
                }
            },
            productReferences: {
                serializedName: "productReferences",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ProductReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ProductReference"
                        }
                    }
                }
            },
            purchasable: {
                serializedName: "purchasable",
                type: {
                    name: "Boolean"
                }
            },
            reviews: {
                serializedName: "reviews",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ReviewElementType",
                        type: {
                            name: "Composite",
                            className: "Review"
                        }
                    }
                }
            },
            stock: {
                serializedName: "stock",
                type: {
                    name: "Composite",
                    className: "Stock"
                }
            },
            summary: {
                serializedName: "summary",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            variantMatrix: {
                serializedName: "variantMatrix",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VariantMatrixElementElementType",
                        type: {
                            name: "Composite",
                            className: "VariantMatrixElement"
                        }
                    }
                }
            },
            variantOptions: {
                serializedName: "variantOptions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VariantOptionElementType",
                        type: {
                            name: "Composite",
                            className: "VariantOption"
                        }
                    }
                }
            },
            variantType: {
                serializedName: "variantType",
                type: {
                    name: "String"
                }
            },
            volumePrices: {
                serializedName: "volumePrices",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PriceElementType",
                        type: {
                            name: "Composite",
                            className: "Price"
                        }
                    }
                }
            },
            volumePricesFlag: {
                serializedName: "volumePricesFlag",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.OrderEntry = {
    serializedName: "OrderEntry",
    type: {
        name: "Composite",
        className: "OrderEntry",
        modelProperties: {
            basePrice: {
                serializedName: "basePrice",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            deliveryMode: {
                serializedName: "deliveryMode",
                type: {
                    name: "Composite",
                    className: "DeliveryMode"
                }
            },
            deliveryPointOfService: {
                serializedName: "deliveryPointOfService",
                type: {
                    name: "Composite",
                    className: "PointOfService"
                }
            },
            entryNumber: {
                serializedName: "entryNumber",
                type: {
                    name: "Number"
                }
            },
            product: {
                serializedName: "product",
                type: {
                    name: "Composite",
                    className: "Product"
                }
            },
            quantity: {
                serializedName: "quantity",
                type: {
                    name: "Number"
                }
            },
            totalPrice: {
                serializedName: "totalPrice",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            updateable: {
                serializedName: "updateable",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.DeliveryOrderEntryGroup = {
    serializedName: "DeliveryOrderEntryGroup",
    type: {
        name: "Composite",
        className: "DeliveryOrderEntryGroup",
        modelProperties: {
            deliveryAddress: {
                serializedName: "deliveryAddress",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            entries: {
                serializedName: "entries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OrderEntryElementType",
                        type: {
                            name: "Composite",
                            className: "OrderEntry"
                        }
                    }
                }
            },
            quantity: {
                serializedName: "quantity",
                type: {
                    name: "Number"
                }
            },
            totalPriceWithTax: {
                serializedName: "totalPriceWithTax",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            }
        }
    }
};
exports.PaymentDetails = {
    serializedName: "PaymentDetails",
    type: {
        name: "Composite",
        className: "PaymentDetails",
        modelProperties: {
            accountHolderName: {
                serializedName: "accountHolderName",
                type: {
                    name: "String"
                }
            },
            billingAddress: {
                serializedName: "billingAddress",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            cardNumber: {
                serializedName: "cardNumber",
                type: {
                    name: "String"
                }
            },
            cardType: {
                serializedName: "cardType",
                type: {
                    name: "Composite",
                    className: "CardType"
                }
            },
            defaultPayment: {
                serializedName: "defaultPayment",
                type: {
                    name: "Boolean"
                }
            },
            expiryMonth: {
                serializedName: "expiryMonth",
                type: {
                    name: "String"
                }
            },
            expiryYear: {
                serializedName: "expiryYear",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            issueNumber: {
                serializedName: "issueNumber",
                type: {
                    name: "String"
                }
            },
            saved: {
                serializedName: "saved",
                type: {
                    name: "Boolean"
                }
            },
            startMonth: {
                serializedName: "startMonth",
                type: {
                    name: "String"
                }
            },
            startYear: {
                serializedName: "startYear",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.PickupOrderEntryGroup = {
    serializedName: "PickupOrderEntryGroup",
    type: {
        name: "Composite",
        className: "PickupOrderEntryGroup",
        modelProperties: {
            deliveryPointOfService: {
                serializedName: "deliveryPointOfService",
                type: {
                    name: "Composite",
                    className: "PointOfService"
                }
            },
            distance: {
                serializedName: "distance",
                type: {
                    name: "Number"
                }
            },
            entries: {
                serializedName: "entries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OrderEntryElementType",
                        type: {
                            name: "Composite",
                            className: "OrderEntry"
                        }
                    }
                }
            },
            quantity: {
                serializedName: "quantity",
                type: {
                    name: "Number"
                }
            },
            totalPriceWithTax: {
                serializedName: "totalPriceWithTax",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            }
        }
    }
};
exports.Principal = {
    serializedName: "Principal",
    type: {
        name: "Composite",
        className: "Principal",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            uid: {
                serializedName: "uid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Cart = {
    serializedName: "Cart",
    type: {
        name: "Composite",
        className: "Cart",
        modelProperties: {
            appliedOrderPromotions: {
                serializedName: "appliedOrderPromotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionResultElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionResult"
                        }
                    }
                }
            },
            appliedProductPromotions: {
                serializedName: "appliedProductPromotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionResultElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionResult"
                        }
                    }
                }
            },
            appliedVouchers: {
                serializedName: "appliedVouchers",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VoucherElementType",
                        type: {
                            name: "Composite",
                            className: "Voucher"
                        }
                    }
                }
            },
            calculated: {
                serializedName: "calculated",
                type: {
                    name: "Boolean"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            deliveryAddress: {
                serializedName: "deliveryAddress",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            deliveryCost: {
                serializedName: "deliveryCost",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            deliveryItemsQuantity: {
                serializedName: "deliveryItemsQuantity",
                type: {
                    name: "Number"
                }
            },
            deliveryMode: {
                serializedName: "deliveryMode",
                type: {
                    name: "Composite",
                    className: "DeliveryMode"
                }
            },
            deliveryOrderGroups: {
                serializedName: "deliveryOrderGroups",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "DeliveryOrderEntryGroupElementType",
                        type: {
                            name: "Composite",
                            className: "DeliveryOrderEntryGroup"
                        }
                    }
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            entries: {
                serializedName: "entries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OrderEntryElementType",
                        type: {
                            name: "Composite",
                            className: "OrderEntry"
                        }
                    }
                }
            },
            expirationTime: {
                serializedName: "expirationTime",
                type: {
                    name: "DateTime"
                }
            },
            guid: {
                serializedName: "guid",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            net: {
                serializedName: "net",
                type: {
                    name: "Boolean"
                }
            },
            orderDiscounts: {
                serializedName: "orderDiscounts",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            paymentInfo: {
                serializedName: "paymentInfo",
                type: {
                    name: "Composite",
                    className: "PaymentDetails"
                }
            },
            pickupItemsQuantity: {
                serializedName: "pickupItemsQuantity",
                type: {
                    name: "Number"
                }
            },
            pickupOrderGroups: {
                serializedName: "pickupOrderGroups",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PickupOrderEntryGroupElementType",
                        type: {
                            name: "Composite",
                            className: "PickupOrderEntryGroup"
                        }
                    }
                }
            },
            potentialOrderPromotions: {
                serializedName: "potentialOrderPromotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionResultElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionResult"
                        }
                    }
                }
            },
            potentialProductPromotions: {
                serializedName: "potentialProductPromotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionResultElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionResult"
                        }
                    }
                }
            },
            productDiscounts: {
                serializedName: "productDiscounts",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            saveTime: {
                serializedName: "saveTime",
                type: {
                    name: "DateTime"
                }
            },
            savedBy: {
                serializedName: "savedBy",
                type: {
                    name: "Composite",
                    className: "Principal"
                }
            },
            site: {
                serializedName: "site",
                type: {
                    name: "String"
                }
            },
            store: {
                serializedName: "store",
                type: {
                    name: "String"
                }
            },
            subTotal: {
                serializedName: "subTotal",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalDiscounts: {
                serializedName: "totalDiscounts",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalItems: {
                serializedName: "totalItems",
                type: {
                    name: "Number"
                }
            },
            totalPrice: {
                serializedName: "totalPrice",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalPriceWithTax: {
                serializedName: "totalPriceWithTax",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalTax: {
                serializedName: "totalTax",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalUnitCount: {
                serializedName: "totalUnitCount",
                type: {
                    name: "Number"
                }
            },
            user: {
                serializedName: "user",
                type: {
                    name: "Composite",
                    className: "Principal"
                }
            }
        }
    }
};
exports.CartList = {
    serializedName: "CartList",
    type: {
        name: "Composite",
        className: "CartList",
        modelProperties: {
            carts: {
                serializedName: "carts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CartElementType",
                        type: {
                            name: "Composite",
                            className: "Cart"
                        }
                    }
                }
            }
        }
    }
};
exports.CartModification = {
    serializedName: "CartModification",
    type: {
        name: "Composite",
        className: "CartModification",
        modelProperties: {
            deliveryModeChanged: {
                serializedName: "deliveryModeChanged",
                type: {
                    name: "Boolean"
                }
            },
            entry: {
                serializedName: "entry",
                type: {
                    name: "Composite",
                    className: "OrderEntry"
                }
            },
            quantity: {
                serializedName: "quantity",
                type: {
                    name: "Number"
                }
            },
            quantityAdded: {
                serializedName: "quantityAdded",
                type: {
                    name: "Number"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "String"
                }
            },
            statusMessage: {
                serializedName: "statusMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CategoryHierarchy = {
    serializedName: "CategoryHierarchy",
    type: {
        name: "Composite",
        className: "CategoryHierarchy",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            subcategories: {
                serializedName: "subcategories",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CategoryHierarchyElementType",
                        type: {
                            name: "Composite",
                            className: "CategoryHierarchy"
                        }
                    }
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CatalogVersion = {
    serializedName: "CatalogVersion",
    type: {
        name: "Composite",
        className: "CatalogVersion",
        modelProperties: {
            categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CategoryHierarchyElementType",
                        type: {
                            name: "Composite",
                            className: "CategoryHierarchy"
                        }
                    }
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.Catalog = {
    serializedName: "Catalog",
    type: {
        name: "Composite",
        className: "Catalog",
        modelProperties: {
            catalogVersions: {
                serializedName: "catalogVersions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CatalogVersionElementType",
                        type: {
                            name: "Composite",
                            className: "CatalogVersion"
                        }
                    }
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                type: {
                    name: "DateTime"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CatalogList = {
    serializedName: "CatalogList",
    type: {
        name: "Composite",
        className: "CatalogList",
        modelProperties: {
            catalogs: {
                serializedName: "catalogs",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CatalogElementType",
                        type: {
                            name: "Composite",
                            className: "Catalog"
                        }
                    }
                }
            }
        }
    }
};
exports.ComponentIDList = {
    serializedName: "ComponentIDList",
    type: {
        name: "Composite",
        className: "ComponentIDList",
        modelProperties: {
            idList: {
                serializedName: "idList",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
exports.ConsignmentEntry = {
    serializedName: "ConsignmentEntry",
    type: {
        name: "Composite",
        className: "ConsignmentEntry",
        modelProperties: {
            orderEntry: {
                serializedName: "orderEntry",
                type: {
                    name: "Composite",
                    className: "OrderEntry"
                }
            },
            quantity: {
                serializedName: "quantity",
                type: {
                    name: "Number"
                }
            },
            shippedQuantity: {
                serializedName: "shippedQuantity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.Consignment = {
    serializedName: "Consignment",
    type: {
        name: "Composite",
        className: "Consignment",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            deliveryPointOfService: {
                serializedName: "deliveryPointOfService",
                type: {
                    name: "Composite",
                    className: "PointOfService"
                }
            },
            entries: {
                serializedName: "entries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ConsignmentEntryElementType",
                        type: {
                            name: "Composite",
                            className: "ConsignmentEntry"
                        }
                    }
                }
            },
            shippingAddress: {
                serializedName: "shippingAddress",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            statusDate: {
                serializedName: "statusDate",
                type: {
                    name: "DateTime"
                }
            },
            trackingID: {
                serializedName: "trackingID",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CountryList = {
    serializedName: "CountryList",
    type: {
        name: "Composite",
        className: "CountryList",
        modelProperties: {
            countries: {
                serializedName: "countries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CountryElementType",
                        type: {
                            name: "Composite",
                            className: "Country"
                        }
                    }
                }
            }
        }
    }
};
exports.CurrencyList = {
    serializedName: "CurrencyList",
    type: {
        name: "Composite",
        className: "CurrencyList",
        modelProperties: {
            currencies: {
                serializedName: "currencies",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "CurrencyElementType",
                        type: {
                            name: "Composite",
                            className: "Currency"
                        }
                    }
                }
            }
        }
    }
};
exports.DeliveryModeList = {
    serializedName: "DeliveryModeList",
    type: {
        name: "Composite",
        className: "DeliveryModeList",
        modelProperties: {
            deliveryModes: {
                serializedName: "deliveryModes",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "DeliveryModeElementType",
                        type: {
                            name: "Composite",
                            className: "DeliveryMode"
                        }
                    }
                }
            }
        }
    }
};
exports.FacetValue = {
    serializedName: "FacetValue",
    type: {
        name: "Composite",
        className: "FacetValue",
        modelProperties: {
            count: {
                serializedName: "count",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            query: {
                serializedName: "query",
                type: {
                    name: "Composite",
                    className: "SearchState"
                }
            },
            selected: {
                serializedName: "selected",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.Facet = {
    serializedName: "Facet",
    type: {
        name: "Composite",
        className: "Facet",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "Boolean"
                }
            },
            multiSelect: {
                serializedName: "multiSelect",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            topValues: {
                serializedName: "topValues",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "FacetValueElementType",
                        type: {
                            name: "Composite",
                            className: "FacetValue"
                        }
                    }
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "FacetValueElementType",
                        type: {
                            name: "Composite",
                            className: "FacetValue"
                        }
                    }
                }
            },
            visible: {
                serializedName: "visible",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.LanguageList = {
    serializedName: "LanguageList",
    type: {
        name: "Composite",
        className: "LanguageList",
        modelProperties: {
            languages: {
                serializedName: "languages",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "LanguageElementType",
                        type: {
                            name: "Composite",
                            className: "Language"
                        }
                    }
                }
            }
        }
    }
};
exports.Pagination = {
    serializedName: "pagination",
    type: {
        name: "Composite",
        className: "Pagination",
        modelProperties: {
            count: {
                serializedName: "count",
                type: {
                    name: "Number"
                }
            },
            page: {
                serializedName: "page",
                type: {
                    name: "Number"
                }
            },
            totalCount: {
                serializedName: "totalCount",
                type: {
                    name: "Number"
                }
            },
            totalPages: {
                serializedName: "totalPages",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.Sort = {
    serializedName: "sort",
    type: {
        name: "Composite",
        className: "Sort",
        modelProperties: {
            asc: {
                serializedName: "asc",
                type: {
                    name: "Boolean"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ListAdaptedComponents = {
    serializedName: "ListAdaptedComponents",
    type: {
        name: "Composite",
        className: "ListAdaptedComponents",
        modelProperties: {
            components: {
                serializedName: "components",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ObjectElementType",
                        type: {
                            name: "Object"
                        }
                    }
                }
            },
            pagination: {
                serializedName: "pagination",
                type: {
                    name: "Composite",
                    className: "Pagination"
                }
            },
            sorts: {
                serializedName: "sorts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "SortElementType",
                        type: {
                            name: "Composite",
                            className: "Sort"
                        }
                    }
                }
            }
        }
    }
};
exports.MemberList = {
    serializedName: "MemberList",
    type: {
        name: "Composite",
        className: "MemberList",
        modelProperties: {
            members: {
                serializedName: "members",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PrincipalElementType",
                        type: {
                            name: "Composite",
                            className: "Principal"
                        }
                    }
                }
            }
        }
    }
};
exports.OrderEntryList = {
    serializedName: "OrderEntryList",
    type: {
        name: "Composite",
        className: "OrderEntryList",
        modelProperties: {
            orderEntries: {
                serializedName: "orderEntries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OrderEntryElementType",
                        type: {
                            name: "Composite",
                            className: "OrderEntry"
                        }
                    }
                }
            }
        }
    }
};
exports.OrderHistory = {
    serializedName: "OrderHistory",
    type: {
        name: "Composite",
        className: "OrderHistory",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            guid: {
                serializedName: "guid",
                type: {
                    name: "String"
                }
            },
            placed: {
                serializedName: "placed",
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            statusDisplay: {
                serializedName: "statusDisplay",
                type: {
                    name: "String"
                }
            },
            total: {
                serializedName: "total",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            }
        }
    }
};
exports.PaginationModel = {
    serializedName: "Pagination",
    type: {
        name: "Composite",
        className: "PaginationModel",
        modelProperties: {
            currentPage: {
                serializedName: "currentPage",
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                type: {
                    name: "Number"
                }
            },
            sort: {
                serializedName: "sort",
                type: {
                    name: "String"
                }
            },
            totalPages: {
                serializedName: "totalPages",
                type: {
                    name: "Number"
                }
            },
            totalResults: {
                serializedName: "totalResults",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.SortModel = {
    serializedName: "Sort",
    type: {
        name: "Composite",
        className: "SortModel",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            selected: {
                serializedName: "selected",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
exports.OrderHistoryList = {
    serializedName: "OrderHistoryList",
    type: {
        name: "Composite",
        className: "OrderHistoryList",
        modelProperties: {
            orders: {
                serializedName: "orders",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OrderHistoryElementType",
                        type: {
                            name: "Composite",
                            className: "OrderHistory"
                        }
                    }
                }
            },
            pagination: {
                serializedName: "pagination",
                type: {
                    name: "Composite",
                    className: "PaginationModel"
                }
            },
            sorts: {
                serializedName: "sorts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "SortModelElementType",
                        type: {
                            name: "Composite",
                            className: "SortModel"
                        }
                    }
                }
            }
        }
    }
};
exports.OrderStatusUpdateElement = {
    serializedName: "OrderStatusUpdateElement",
    type: {
        name: "Composite",
        className: "OrderStatusUpdateElement",
        modelProperties: {
            baseSiteId: {
                serializedName: "baseSiteId",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.OrderStatusUpdateElementList = {
    serializedName: "OrderStatusUpdateElementList",
    type: {
        name: "Composite",
        className: "OrderStatusUpdateElementList",
        modelProperties: {
            orderStatusUpdateElements: {
                serializedName: "orderStatusUpdateElements",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OrderStatusUpdateElementElementType",
                        type: {
                            name: "Composite",
                            className: "OrderStatusUpdateElement"
                        }
                    }
                }
            }
        }
    }
};
exports.Order = {
    serializedName: "Order",
    type: {
        name: "Composite",
        className: "Order",
        modelProperties: {
            appliedOrderPromotions: {
                serializedName: "appliedOrderPromotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionResultElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionResult"
                        }
                    }
                }
            },
            appliedProductPromotions: {
                serializedName: "appliedProductPromotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionResultElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionResult"
                        }
                    }
                }
            },
            appliedVouchers: {
                serializedName: "appliedVouchers",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VoucherElementType",
                        type: {
                            name: "Composite",
                            className: "Voucher"
                        }
                    }
                }
            },
            calculated: {
                serializedName: "calculated",
                type: {
                    name: "Boolean"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            consignments: {
                serializedName: "consignments",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ConsignmentElementType",
                        type: {
                            name: "Composite",
                            className: "Consignment"
                        }
                    }
                }
            },
            created: {
                serializedName: "created",
                type: {
                    name: "DateTime"
                }
            },
            deliveryAddress: {
                serializedName: "deliveryAddress",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            deliveryCost: {
                serializedName: "deliveryCost",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            deliveryItemsQuantity: {
                serializedName: "deliveryItemsQuantity",
                type: {
                    name: "Number"
                }
            },
            deliveryMode: {
                serializedName: "deliveryMode",
                type: {
                    name: "Composite",
                    className: "DeliveryMode"
                }
            },
            deliveryOrderGroups: {
                serializedName: "deliveryOrderGroups",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "DeliveryOrderEntryGroupElementType",
                        type: {
                            name: "Composite",
                            className: "DeliveryOrderEntryGroup"
                        }
                    }
                }
            },
            deliveryStatus: {
                serializedName: "deliveryStatus",
                type: {
                    name: "String"
                }
            },
            deliveryStatusDisplay: {
                serializedName: "deliveryStatusDisplay",
                type: {
                    name: "String"
                }
            },
            entries: {
                serializedName: "entries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OrderEntryElementType",
                        type: {
                            name: "Composite",
                            className: "OrderEntry"
                        }
                    }
                }
            },
            guestCustomer: {
                serializedName: "guestCustomer",
                type: {
                    name: "Boolean"
                }
            },
            guid: {
                serializedName: "guid",
                type: {
                    name: "String"
                }
            },
            net: {
                serializedName: "net",
                type: {
                    name: "Boolean"
                }
            },
            orderDiscounts: {
                serializedName: "orderDiscounts",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            paymentInfo: {
                serializedName: "paymentInfo",
                type: {
                    name: "Composite",
                    className: "PaymentDetails"
                }
            },
            pickupItemsQuantity: {
                serializedName: "pickupItemsQuantity",
                type: {
                    name: "Number"
                }
            },
            pickupOrderGroups: {
                serializedName: "pickupOrderGroups",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PickupOrderEntryGroupElementType",
                        type: {
                            name: "Composite",
                            className: "PickupOrderEntryGroup"
                        }
                    }
                }
            },
            productDiscounts: {
                serializedName: "productDiscounts",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            site: {
                serializedName: "site",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            statusDisplay: {
                serializedName: "statusDisplay",
                type: {
                    name: "String"
                }
            },
            store: {
                serializedName: "store",
                type: {
                    name: "String"
                }
            },
            subTotal: {
                serializedName: "subTotal",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalDiscounts: {
                serializedName: "totalDiscounts",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalItems: {
                serializedName: "totalItems",
                type: {
                    name: "Number"
                }
            },
            totalPrice: {
                serializedName: "totalPrice",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalPriceWithTax: {
                serializedName: "totalPriceWithTax",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            totalTax: {
                serializedName: "totalTax",
                type: {
                    name: "Composite",
                    className: "Price"
                }
            },
            unconsignedEntries: {
                serializedName: "unconsignedEntries",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "OrderEntryElementType",
                        type: {
                            name: "Composite",
                            className: "OrderEntry"
                        }
                    }
                }
            },
            user: {
                serializedName: "user",
                type: {
                    name: "Composite",
                    className: "Principal"
                }
            }
        }
    }
};
exports.PaymentDetailsList = {
    serializedName: "PaymentDetailsList",
    type: {
        name: "Composite",
        className: "PaymentDetailsList",
        modelProperties: {
            payments: {
                serializedName: "payments",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PaymentDetailsElementType",
                        type: {
                            name: "Composite",
                            className: "PaymentDetails"
                        }
                    }
                }
            }
        }
    }
};
exports.PointOfServiceStock = {
    serializedName: "PointOfServiceStock",
    type: {
        name: "Composite",
        className: "PointOfServiceStock",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            distanceKm: {
                serializedName: "distanceKm",
                type: {
                    name: "Number"
                }
            },
            features: {
                serializedName: "features",
                type: {
                    name: "Dictionary",
                    value: {
                        serializedName: "stringElementType",
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            formattedDistance: {
                serializedName: "formattedDistance",
                type: {
                    name: "String"
                }
            },
            geoPoint: {
                serializedName: "geoPoint",
                type: {
                    name: "Composite",
                    className: "GeoPoint"
                }
            },
            mapIcon: {
                serializedName: "mapIcon",
                type: {
                    name: "Composite",
                    className: "Image"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            openingHours: {
                serializedName: "openingHours",
                type: {
                    name: "Composite",
                    className: "OpeningSchedule"
                }
            },
            stockInfo: {
                serializedName: "stockInfo",
                type: {
                    name: "Composite",
                    className: "Stock"
                }
            },
            storeContent: {
                serializedName: "storeContent",
                type: {
                    name: "String"
                }
            },
            storeImages: {
                serializedName: "storeImages",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ImageElementType",
                        type: {
                            name: "Composite",
                            className: "Image"
                        }
                    }
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ProductExpressUpdateElement = {
    serializedName: "ProductExpressUpdateElement",
    type: {
        name: "Composite",
        className: "ProductExpressUpdateElement",
        modelProperties: {
            catalogId: {
                serializedName: "catalogId",
                type: {
                    name: "String"
                }
            },
            catalogVersion: {
                serializedName: "catalogVersion",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ProductExpressUpdateElementList = {
    serializedName: "ProductExpressUpdateElementList",
    type: {
        name: "Composite",
        className: "ProductExpressUpdateElementList",
        modelProperties: {
            productExpressUpdateElements: {
                serializedName: "productExpressUpdateElements",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ProductExpressUpdateElementElementType",
                        type: {
                            name: "Composite",
                            className: "ProductExpressUpdateElement"
                        }
                    }
                }
            }
        }
    }
};
exports.ProductList = {
    serializedName: "ProductList",
    type: {
        name: "Composite",
        className: "ProductList",
        modelProperties: {
            catalog: {
                serializedName: "catalog",
                type: {
                    name: "String"
                }
            },
            currentPage: {
                serializedName: "currentPage",
                type: {
                    name: "Number"
                }
            },
            products: {
                serializedName: "products",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ProductElementType",
                        type: {
                            name: "Composite",
                            className: "Product"
                        }
                    }
                }
            },
            totalPageCount: {
                serializedName: "totalPageCount",
                type: {
                    name: "Number"
                }
            },
            totalProductCount: {
                serializedName: "totalProductCount",
                type: {
                    name: "Number"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ProductReferenceList = {
    serializedName: "ProductReferenceList",
    type: {
        name: "Composite",
        className: "ProductReferenceList",
        modelProperties: {
            references: {
                serializedName: "references",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ProductReferenceElementType",
                        type: {
                            name: "Composite",
                            className: "ProductReference"
                        }
                    }
                }
            }
        }
    }
};
exports.SpellingSuggestion = {
    serializedName: "SpellingSuggestion",
    type: {
        name: "Composite",
        className: "SpellingSuggestion",
        modelProperties: {
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            },
            suggestion: {
                serializedName: "suggestion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.ProductSearchPage = {
    serializedName: "ProductSearchPage",
    type: {
        name: "Composite",
        className: "ProductSearchPage",
        modelProperties: {
            breadcrumbs: {
                serializedName: "breadcrumbs",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "BreadcrumbElementType",
                        type: {
                            name: "Composite",
                            className: "Breadcrumb"
                        }
                    }
                }
            },
            categoryCode: {
                serializedName: "categoryCode",
                type: {
                    name: "String"
                }
            },
            currentQuery: {
                serializedName: "currentQuery",
                type: {
                    name: "Composite",
                    className: "SearchState"
                }
            },
            facets: {
                serializedName: "facets",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "FacetElementType",
                        type: {
                            name: "Composite",
                            className: "Facet"
                        }
                    }
                }
            },
            freeTextSearch: {
                serializedName: "freeTextSearch",
                type: {
                    name: "String"
                }
            },
            keywordRedirectUrl: {
                serializedName: "keywordRedirectUrl",
                type: {
                    name: "String"
                }
            },
            pagination: {
                serializedName: "pagination",
                type: {
                    name: "Composite",
                    className: "PaginationModel"
                }
            },
            products: {
                serializedName: "products",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ProductElementType",
                        type: {
                            name: "Composite",
                            className: "Product"
                        }
                    }
                }
            },
            sorts: {
                serializedName: "sorts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "SortModelElementType",
                        type: {
                            name: "Composite",
                            className: "SortModel"
                        }
                    }
                }
            },
            spellingSuggestion: {
                serializedName: "spellingSuggestion",
                type: {
                    name: "Composite",
                    className: "SpellingSuggestion"
                }
            }
        }
    }
};
exports.PromotionList = {
    serializedName: "PromotionList",
    type: {
        name: "Composite",
        className: "PromotionList",
        modelProperties: {
            promotions: {
                serializedName: "promotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionElementType",
                        type: {
                            name: "Composite",
                            className: "Promotion"
                        }
                    }
                }
            }
        }
    }
};
exports.PromotionResultList = {
    serializedName: "PromotionResultList",
    type: {
        name: "Composite",
        className: "PromotionResultList",
        modelProperties: {
            promotions: {
                serializedName: "promotions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PromotionResultElementType",
                        type: {
                            name: "Composite",
                            className: "PromotionResult"
                        }
                    }
                }
            }
        }
    }
};
exports.ReviewList = {
    serializedName: "ReviewList",
    type: {
        name: "Composite",
        className: "ReviewList",
        modelProperties: {
            reviews: {
                serializedName: "reviews",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "ReviewElementType",
                        type: {
                            name: "Composite",
                            className: "Review"
                        }
                    }
                }
            }
        }
    }
};
exports.SaveCartResult = {
    serializedName: "SaveCartResult",
    type: {
        name: "Composite",
        className: "SaveCartResult",
        modelProperties: {
            savedCartData: {
                serializedName: "savedCartData",
                type: {
                    name: "Composite",
                    className: "Cart"
                }
            }
        }
    }
};
exports.StoreFinderSearchPage = {
    serializedName: "StoreFinderSearchPage",
    type: {
        name: "Composite",
        className: "StoreFinderSearchPage",
        modelProperties: {
            boundEastLongitude: {
                serializedName: "boundEastLongitude",
                type: {
                    name: "Number"
                }
            },
            boundNorthLatitude: {
                serializedName: "boundNorthLatitude",
                type: {
                    name: "Number"
                }
            },
            boundSouthLatitude: {
                serializedName: "boundSouthLatitude",
                type: {
                    name: "Number"
                }
            },
            boundWestLongitude: {
                serializedName: "boundWestLongitude",
                type: {
                    name: "Number"
                }
            },
            locationText: {
                serializedName: "locationText",
                type: {
                    name: "String"
                }
            },
            pagination: {
                serializedName: "pagination",
                type: {
                    name: "Composite",
                    className: "PaginationModel"
                }
            },
            sorts: {
                serializedName: "sorts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "SortModelElementType",
                        type: {
                            name: "Composite",
                            className: "SortModel"
                        }
                    }
                }
            },
            sourceLatitude: {
                serializedName: "sourceLatitude",
                type: {
                    name: "Number"
                }
            },
            sourceLongitude: {
                serializedName: "sourceLongitude",
                type: {
                    name: "Number"
                }
            },
            stores: {
                serializedName: "stores",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PointOfServiceElementType",
                        type: {
                            name: "Composite",
                            className: "PointOfService"
                        }
                    }
                }
            }
        }
    }
};
exports.StoreFinderStockSearchPage = {
    serializedName: "StoreFinderStockSearchPage",
    type: {
        name: "Composite",
        className: "StoreFinderStockSearchPage",
        modelProperties: {
            boundEastLongitude: {
                serializedName: "boundEastLongitude",
                type: {
                    name: "Number"
                }
            },
            boundNorthLatitude: {
                serializedName: "boundNorthLatitude",
                type: {
                    name: "Number"
                }
            },
            boundSouthLatitude: {
                serializedName: "boundSouthLatitude",
                type: {
                    name: "Number"
                }
            },
            boundWestLongitude: {
                serializedName: "boundWestLongitude",
                type: {
                    name: "Number"
                }
            },
            locationText: {
                serializedName: "locationText",
                type: {
                    name: "String"
                }
            },
            pagination: {
                serializedName: "pagination",
                type: {
                    name: "Composite",
                    className: "PaginationModel"
                }
            },
            product: {
                serializedName: "product",
                type: {
                    name: "Composite",
                    className: "Product"
                }
            },
            sorts: {
                serializedName: "sorts",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "SortModelElementType",
                        type: {
                            name: "Composite",
                            className: "SortModel"
                        }
                    }
                }
            },
            sourceLatitude: {
                serializedName: "sourceLatitude",
                type: {
                    name: "Number"
                }
            },
            sourceLongitude: {
                serializedName: "sourceLongitude",
                type: {
                    name: "Number"
                }
            },
            stores: {
                serializedName: "stores",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PointOfServiceStockElementType",
                        type: {
                            name: "Composite",
                            className: "PointOfServiceStock"
                        }
                    }
                }
            }
        }
    }
};
exports.Suggestion = {
    serializedName: "Suggestion",
    type: {
        name: "Composite",
        className: "Suggestion",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.SuggestionList = {
    serializedName: "SuggestionList",
    type: {
        name: "Composite",
        className: "SuggestionList",
        modelProperties: {
            suggestions: {
                serializedName: "suggestions",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "SuggestionElementType",
                        type: {
                            name: "Composite",
                            className: "Suggestion"
                        }
                    }
                }
            }
        }
    }
};
exports.Title = {
    serializedName: "Title",
    type: {
        name: "Composite",
        className: "Title",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.TitleList = {
    serializedName: "TitleList",
    type: {
        name: "Composite",
        className: "TitleList",
        modelProperties: {
            titles: {
                serializedName: "titles",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "TitleElementType",
                        type: {
                            name: "Composite",
                            className: "Title"
                        }
                    }
                }
            }
        }
    }
};
exports.UserGroup = {
    serializedName: "UserGroup",
    type: {
        name: "Composite",
        className: "UserGroup",
        modelProperties: {
            members: {
                serializedName: "members",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "PrincipalElementType",
                        type: {
                            name: "Composite",
                            className: "Principal"
                        }
                    }
                }
            },
            membersCount: {
                serializedName: "membersCount",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            subGroups: {
                serializedName: "subGroups",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "UserGroupElementType",
                        type: {
                            name: "Composite",
                            className: "UserGroup"
                        }
                    }
                }
            },
            uid: {
                serializedName: "uid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.UserGroupList = {
    serializedName: "UserGroupList",
    type: {
        name: "Composite",
        className: "UserGroupList",
        modelProperties: {
            currentPage: {
                serializedName: "currentPage",
                type: {
                    name: "Number"
                }
            },
            numberOfPages: {
                serializedName: "numberOfPages",
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                type: {
                    name: "Number"
                }
            },
            totalNumber: {
                serializedName: "totalNumber",
                type: {
                    name: "Number"
                }
            },
            userGroups: {
                serializedName: "userGroups",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "UserGroupElementType",
                        type: {
                            name: "Composite",
                            className: "UserGroup"
                        }
                    }
                }
            }
        }
    }
};
exports.UserSignUp = {
    serializedName: "UserSignUp",
    type: {
        name: "Composite",
        className: "UserSignUp",
        modelProperties: {
            firstName: {
                serializedName: "firstName",
                type: {
                    name: "String"
                }
            },
            lastName: {
                serializedName: "lastName",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            titleCode: {
                serializedName: "titleCode",
                type: {
                    name: "String"
                }
            },
            uid: {
                serializedName: "uid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.VoucherList = {
    serializedName: "VoucherList",
    type: {
        name: "Composite",
        className: "VoucherList",
        modelProperties: {
            vouchers: {
                serializedName: "vouchers",
                type: {
                    name: "Sequence",
                    element: {
                        serializedName: "VoucherElementType",
                        type: {
                            name: "Composite",
                            className: "Voucher"
                        }
                    }
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCardTypesOptionalParams = {
    serializedName: "GetCardTypesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCardTypesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCatalogsOptionalParams = {
    serializedName: "GetCatalogsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCatalogsOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCatalogOptionalParams = {
    serializedName: "GetCatalogOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCatalogOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCatalogVersionOptionalParams = {
    serializedName: "GetCatalogVersionOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCatalogVersionOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCategoriesOptionalParams = {
    serializedName: "GetCategoriesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCategoriesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetComponentByIdListOptionalParams = {
    serializedName: "GetComponentByIdListOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetComponentByIdListOptionalParams",
        modelProperties: {
            catalogCode: {
                serializedName: "catalogCode",
                type: {
                    name: "String"
                }
            },
            productCode: {
                serializedName: "productCode",
                type: {
                    name: "String"
                }
            },
            categoryCode: {
                serializedName: "categoryCode",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            },
            currentPage: {
                serializedName: "currentPage",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 10,
                type: {
                    name: "Number"
                }
            },
            sort: {
                serializedName: "sort",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetComponentByIdOptionalParams = {
    serializedName: "GetComponentByIdOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetComponentByIdOptionalParams",
        modelProperties: {
            catalogCode: {
                serializedName: "catalogCode",
                type: {
                    name: "String"
                }
            },
            productCode: {
                serializedName: "productCode",
                type: {
                    name: "String"
                }
            },
            categoryCode: {
                serializedName: "categoryCode",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetPageDataOptionalParams = {
    serializedName: "GetPageDataOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetPageDataOptionalParams",
        modelProperties: {
            pageType: {
                serializedName: "pageType",
                defaultValue: 'ContentPage',
                type: {
                    name: "String"
                }
            },
            pageLabelOrId: {
                serializedName: "pageLabelOrId",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCurrenciesOptionalParams = {
    serializedName: "GetCurrenciesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCurrenciesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetAllCustomerGroupsOptionalParams = {
    serializedName: "GetAllCustomerGroupsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetAllCustomerGroupsOptionalParams",
        modelProperties: {
            currentPage: {
                serializedName: "currentPage",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 20,
                type: {
                    name: "Number"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'BASIC',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCustomerGroupOptionalParams = {
    serializedName: "GetCustomerGroupOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCustomerGroupOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'BASIC',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetDeliveryCountriesOptionalParams = {
    serializedName: "GetDeliveryCountriesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetDeliveryCountriesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2ExportProductsOptionalParams = {
    serializedName: "ExportProductsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2ExportProductsOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            },
            currentPage: {
                serializedName: "currentPage",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 20,
                type: {
                    name: "Number"
                }
            },
            catalog: {
                serializedName: "catalog",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2OrderStatusFeedOptionalParams = {
    serializedName: "OrderStatusFeedOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2OrderStatusFeedOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetLanguagesOptionalParams = {
    serializedName: "GetLanguagesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetLanguagesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetOrderOptionalParams = {
    serializedName: "GetOrderOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetOrderOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2ExpressUpdateOptionalParams = {
    serializedName: "ExpressUpdateOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2ExpressUpdateOptionalParams",
        modelProperties: {
            catalog: {
                serializedName: "catalog",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2SearchProductsOptionalParams = {
    serializedName: "SearchProductsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2SearchProductsOptionalParams",
        modelProperties: {
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            },
            currentPage: {
                serializedName: "currentPage",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 20,
                type: {
                    name: "Number"
                }
            },
            sort: {
                serializedName: "sort",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            },
            searchQueryContext: {
                serializedName: "searchQueryContext",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2CountSearchProductsOptionalParams = {
    serializedName: "CountSearchProductsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2CountSearchProductsOptionalParams",
        modelProperties: {
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetSuggestionsOptionalParams = {
    serializedName: "GetSuggestionsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetSuggestionsOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetProductByCodeOptionalParams = {
    serializedName: "GetProductByCodeOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetProductByCodeOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2ExportProductReferencesOptionalParams = {
    serializedName: "ExportProductReferencesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2ExportProductReferencesOptionalParams",
        modelProperties: {
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 2147483647,
                type: {
                    name: "Number"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetProductReviewsOptionalParams = {
    serializedName: "GetProductReviewsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetProductReviewsOptionalParams",
        modelProperties: {
            maxCount: {
                serializedName: "maxCount",
                type: {
                    name: "Number"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2CreateReviewPrimOptionalParams = {
    serializedName: "CreateReviewPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2CreateReviewPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2SearchProductStockByLocationOptionalParams = {
    serializedName: "SearchProductStockByLocationOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2SearchProductStockByLocationOptionalParams",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            latitude: {
                serializedName: "latitude",
                type: {
                    name: "Number"
                }
            },
            longitude: {
                serializedName: "longitude",
                type: {
                    name: "Number"
                }
            },
            currentPage: {
                serializedName: "currentPage",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 20,
                type: {
                    name: "Number"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2CountSearchProductStockByLocationOptionalParams = {
    serializedName: "CountSearchProductStockByLocationOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2CountSearchProductStockByLocationOptionalParams",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            latitude: {
                serializedName: "latitude",
                type: {
                    name: "Number"
                }
            },
            longitude: {
                serializedName: "longitude",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetStockDataOptionalParams = {
    serializedName: "GetStockDataOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetStockDataOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetPromotionsPrimOptionalParams = {
    serializedName: "GetPromotionsPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetPromotionsPrimOptionalParams",
        modelProperties: {
            promotionGroup: {
                serializedName: "promotionGroup",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'BASIC',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetPromotionByCodeOptionalParams = {
    serializedName: "GetPromotionByCodeOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetPromotionByCodeOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'BASIC',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2LocationSearchOptionalParams = {
    serializedName: "LocationSearchOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2LocationSearchOptionalParams",
        modelProperties: {
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            },
            latitude: {
                serializedName: "latitude",
                type: {
                    name: "Number"
                }
            },
            longitude: {
                serializedName: "longitude",
                type: {
                    name: "Number"
                }
            },
            currentPage: {
                serializedName: "currentPage",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 20,
                type: {
                    name: "Number"
                }
            },
            sort: {
                serializedName: "sort",
                defaultValue: 'asc',
                type: {
                    name: "String"
                }
            },
            radius: {
                serializedName: "radius",
                defaultValue: 100000,
                type: {
                    name: "Number"
                }
            },
            accuracy: {
                serializedName: "accuracy",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2CountLocationSearchOptionalParams = {
    serializedName: "CountLocationSearchOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2CountLocationSearchOptionalParams",
        modelProperties: {
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            },
            latitude: {
                serializedName: "latitude",
                type: {
                    name: "Number"
                }
            },
            longitude: {
                serializedName: "longitude",
                type: {
                    name: "Number"
                }
            },
            radius: {
                serializedName: "radius",
                defaultValue: 100000,
                type: {
                    name: "Number"
                }
            },
            accuracy: {
                serializedName: "accuracy",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2LocationDetailsOptionalParams = {
    serializedName: "LocationDetailsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2LocationDetailsOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetTitlesOptionalParams = {
    serializedName: "GetTitlesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetTitlesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2RegisterUserPrimOptionalParams = {
    serializedName: "RegisterUserPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2RegisterUserPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetUserOptionalParams = {
    serializedName: "GetUserOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetUserOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetAddressesOptionalParams = {
    serializedName: "GetAddressesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetAddressesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2CreateAddressPrimOptionalParams = {
    serializedName: "CreateAddressPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2CreateAddressPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2VerifyAddressPrimOptionalParams = {
    serializedName: "VerifyAddressPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2VerifyAddressPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetAddressOptionalParams = {
    serializedName: "GetAddressOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetAddressOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCartsOptionalParams = {
    serializedName: "GetCartsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCartsOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            },
            savedCartsOnly: {
                serializedName: "savedCartsOnly",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            currentPage: {
                serializedName: "currentPage",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 20,
                type: {
                    name: "Number"
                }
            },
            sort: {
                serializedName: "sort",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2CreateCartOptionalParams = {
    serializedName: "CreateCartOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2CreateCartOptionalParams",
        modelProperties: {
            oldCartId: {
                serializedName: "oldCartId",
                type: {
                    name: "String"
                }
            },
            toMergeCartGuid: {
                serializedName: "toMergeCartGuid",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCartOptionalParams = {
    serializedName: "GetCartOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCartOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2CreateAndSetAddressPrimOptionalParams = {
    serializedName: "CreateAndSetAddressPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2CreateAndSetAddressPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2CloneSaveCartOptionalParams = {
    serializedName: "CloneSaveCartOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2CloneSaveCartOptionalParams",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCartDeliveryModeOptionalParams = {
    serializedName: "GetCartDeliveryModeOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCartDeliveryModeOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetSupportedDeliveryModesOptionalParams = {
    serializedName: "GetSupportedDeliveryModesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetSupportedDeliveryModesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCartEntriesOptionalParams = {
    serializedName: "GetCartEntriesOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCartEntriesOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2AddCartEntryPrimOptionalParams = {
    serializedName: "AddCartEntryPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2AddCartEntryPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCartEntryOptionalParams = {
    serializedName: "GetCartEntryOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCartEntryOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2SetCartEntryPrimOptionalParams = {
    serializedName: "SetCartEntryPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2SetCartEntryPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2UpdateCartEntryPrimOptionalParams = {
    serializedName: "UpdateCartEntryPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2UpdateCartEntryPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2FlagForDeletionOptionalParams = {
    serializedName: "FlagForDeletionOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2FlagForDeletionOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2AddPaymentDetailsPrimOptionalParams = {
    serializedName: "AddPaymentDetailsPrimOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2AddPaymentDetailsPrimOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetPromotionsOptionalParams = {
    serializedName: "GetPromotionsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetPromotionsOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetPromotionOptionalParams = {
    serializedName: "GetPromotionOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetPromotionOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2RestoreSavedCartOptionalParams = {
    serializedName: "RestoreSavedCartOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2RestoreSavedCartOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2SaveCartOptionalParams = {
    serializedName: "SaveCartOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2SaveCartOptionalParams",
        modelProperties: {
            saveCartName: {
                serializedName: "saveCartName",
                type: {
                    name: "String"
                }
            },
            saveCartDescription: {
                serializedName: "saveCartDescription",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetSavedCartOptionalParams = {
    serializedName: "GetSavedCartOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetSavedCartOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetVouchersOptionalParams = {
    serializedName: "GetVouchersOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetVouchersOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetAllCustomerGroupsForCustomerOptionalParams = {
    serializedName: "GetAllCustomerGroupsForCustomerOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetAllCustomerGroupsForCustomerOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetOrdersForUserOptionalParams = {
    serializedName: "GetOrdersForUserOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetOrdersForUserOptionalParams",
        modelProperties: {
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "String"
                }
            },
            currentPage: {
                serializedName: "currentPage",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            pageSize: {
                serializedName: "pageSize",
                defaultValue: 20,
                type: {
                    name: "Number"
                }
            },
            sort: {
                serializedName: "sort",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetCountOrdersForUserOptionalParams = {
    serializedName: "GetCountOrdersForUserOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetCountOrdersForUserOptionalParams",
        modelProperties: {
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2PlaceOrderOptionalParams = {
    serializedName: "PlaceOrderOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2PlaceOrderOptionalParams",
        modelProperties: {
            securityCode: {
                serializedName: "securityCode",
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetOrderForUserByCodeOptionalParams = {
    serializedName: "GetOrderForUserByCodeOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetOrderForUserByCodeOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2ChangePasswordOptionalParams = {
    serializedName: "ChangePasswordOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2ChangePasswordOptionalParams",
        modelProperties: {
            old: {
                serializedName: "old",
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetPaymentInfosOptionalParams = {
    serializedName: "GetPaymentInfosOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetPaymentInfosOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetPaymentDetailsOptionalParams = {
    serializedName: "GetPaymentDetailsOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetPaymentDetailsOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'DEFAULT',
                type: {
                    name: "String"
                }
            }
        }
    }
};
exports.CommerceWebservicesV2GetVoucherByCodeOptionalParams = {
    serializedName: "GetVoucherByCodeOptions",
    type: {
        name: "Composite",
        className: "CommerceWebservicesV2GetVoucherByCodeOptionalParams",
        modelProperties: {
            fields: {
                serializedName: "fields",
                defaultValue: 'BASIC',
                type: {
                    name: "String"
                }
            }
        }
    }
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const msRest = __webpack_require__(0);
const packageName = "hybris-occ-client";
const packageVersion = "0.1.1";
class CommerceWebservicesV2Context extends msRest.ServiceClient {
    /**
     * @class
     * Initializes a new instance of the CommerceWebservicesV2Context class.
     * @constructor
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     */
    constructor(baseUri, options) {
        if (!options) {
            options = {};
        }
        super(undefined, options);
        this.baseUri = baseUri;
        if (!this.baseUri) {
            this.baseUri = "http://backoffice.christian-spartacus1-s2-public.model-t.myhybris.cloud";
        }
        this.addUserAgentInfo(`${packageName}/${packageVersion}`);
    }
}
exports.CommerceWebservicesV2Context = CommerceWebservicesV2Context;


/***/ })
/******/ ]);
//# sourceMappingURL=commerceWebservicesV2Bundle.js.map