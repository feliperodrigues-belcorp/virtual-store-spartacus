"use strict";
/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const msRest = require("ms-rest-js");
const Models = require("./models");
exports.CommerceWebservicesV2Models = Models;
const Mappers = require("./models/mappers");
exports.CommerceWebservicesV2Mappers = Mappers;
const commerceWebservicesV2Context_1 = require("./commerceWebservicesV2Context");
const WebResource = msRest.WebResource;
class CommerceWebservicesV2 extends commerceWebservicesV2Context_1.CommerceWebservicesV2Context {
    /**
     * @class
     * Initializes a new instance of the CommerceWebservicesV2 class.
     * @constructor
     *
     * @param {string} [baseUri] - The base URI of the service.
     *
     * @param {object} [options] - The parameter options
     *
     * @param {Array} [options.filters] - Filters to be added to the request pipeline
     *
     * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
     * {@link https://github.github.io/fetch/#Request Options doc}
     *
     * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
     *
     */
    constructor(baseUri, options) {
        super(baseUri, options);
        this.serializer = new msRest.Serializer(Mappers);
    }
    // methods on the client.
    /**
     * @summary Get a list of supported payment card types.
     *
     * Lists supported payment card types.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCardTypesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCardTypesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/cardtypes",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CardTypeList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CardTypeList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of catalogs
     *
     * Returns all catalogs with versions defined for the base store.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCatalogsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCatalogsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/catalogs",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CatalogList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CatalogList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a catalog
     *
     * Returns information about a catalog based on its ID, along with the versions defined for the
     * current base store.
     *
     * @param {string} catalogId Catalog identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCatalogOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCatalogWithHttpOperationResponse(catalogId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    catalogId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/catalogs/{catalogId}",
                    urlParameters: [
                        {
                            parameterPath: "catalogId",
                            mapper: {
                                required: true,
                                serializedName: "catalogId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Catalog
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Catalog;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get information about catalog version
     *
     * Returns information about the catalog version that exists for the current base store.
     *
     * @param {string} catalogId Catalog identifier
     *
     * @param {string} catalogVersionId Catalog version identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCatalogVersionOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCatalogVersionWithHttpOperationResponse(catalogId, catalogVersionId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    catalogId,
                    catalogVersionId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/catalogs/{catalogId}/{catalogVersionId}",
                    urlParameters: [
                        {
                            parameterPath: "catalogId",
                            mapper: {
                                required: true,
                                serializedName: "catalogId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "catalogVersionId",
                            mapper: {
                                required: true,
                                serializedName: "catalogVersionId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CatalogVersion
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CatalogVersion;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get information about catagory in a catalog version
     *
     * Returns information about a specified category that exists in a catalog version available for
     * the current base store.
     *
     * @param {string} catalogId Catalog identifier
     *
     * @param {string} catalogVersionId Catalog version identifier
     *
     * @param {string} categoryId Category identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCategoriesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCategoriesWithHttpOperationResponse(catalogId, catalogVersionId, categoryId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    catalogId,
                    catalogVersionId,
                    categoryId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/catalogs/{catalogId}/{catalogVersionId}/categories/{categoryId}",
                    urlParameters: [
                        {
                            parameterPath: "catalogId",
                            mapper: {
                                required: true,
                                serializedName: "catalogId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "catalogVersionId",
                            mapper: {
                                required: true,
                                serializedName: "catalogVersionId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "categoryId",
                            mapper: {
                                required: true,
                                serializedName: "categoryId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CategoryHierarchy
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CategoryHierarchy;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get components' data by id given in body
     *
     * Given a list of component identifiers in body, return cms component data.
     *
     * @param {ComponentIDList} componentIdList List of Component identifiers
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetComponentByIdListOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getComponentByIdListWithHttpOperationResponse(componentIdList, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let catalogCode = (options && options.catalogCode !== undefined) ? options.catalogCode : undefined;
            let productCode = (options && options.productCode !== undefined) ? options.productCode : undefined;
            let categoryCode = (options && options.categoryCode !== undefined) ? options.categoryCode : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 10;
            let sort = (options && options.sort !== undefined) ? options.sort : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    componentIdList,
                    catalogCode,
                    productCode,
                    categoryCode,
                    fields,
                    currentPage,
                    pageSize,
                    sort,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/cms/components",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "catalogCode",
                            mapper: {
                                serializedName: "catalogCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "productCode",
                            mapper: {
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "categoryCode",
                            mapper: {
                                serializedName: "categoryCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 10,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "componentIdList",
                        mapper: Object.assign({}, Mappers.ComponentIDList, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.ListAdaptedComponents
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ListAdaptedComponents;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get component data
     *
     * Given a component identifier, return cms component data.
     *
     * @param {string} componentId Component identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetComponentByIdOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getComponentByIdWithHttpOperationResponse(componentId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let catalogCode = (options && options.catalogCode !== undefined) ? options.catalogCode : undefined;
            let productCode = (options && options.productCode !== undefined) ? options.productCode : undefined;
            let categoryCode = (options && options.categoryCode !== undefined) ? options.categoryCode : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    componentId,
                    catalogCode,
                    productCode,
                    categoryCode,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/cms/components/{componentId}",
                    urlParameters: [
                        {
                            parameterPath: "componentId",
                            mapper: {
                                required: true,
                                serializedName: "componentId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "catalogCode",
                            mapper: {
                                serializedName: "catalogCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "productCode",
                            mapper: {
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "categoryCode",
                            mapper: {
                                serializedName: "categoryCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            }
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = {
                                serializedName: "parsedResponse",
                                type: {
                                    name: "Object"
                                }
                            };
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get page data with list of cms content slots
     *
     * Given a page identifier, return the page data with a list of cms content slots, each of which
     * contains a list of cms component data.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetPageDataOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPageDataWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let pageType = (options && options.pageType !== undefined) ? options.pageType : 'ContentPage';
            let pageLabelOrId = (options && options.pageLabelOrId !== undefined) ? options.pageLabelOrId : undefined;
            let code = (options && options.code !== undefined) ? options.code : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    pageType,
                    pageLabelOrId,
                    code,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/cms/pages",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "pageType",
                            mapper: {
                                serializedName: "pageType",
                                defaultValue: 'ContentPage',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "pageLabelOrId",
                            mapper: {
                                serializedName: "pageLabelOrId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "code",
                            mapper: {
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CMSPage
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CMSPage;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of available currencies.
     *
     * Lists all available currencies (all usable currencies for the current store). If the list of
     * currencies for a base store is empty, a list of all currencies available in the system is
     * returned.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCurrenciesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCurrenciesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/currencies",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CurrencyList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CurrencyList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get all subgroups of a customergroup.
     *
     * Returns all customer groups that are direct subgroups of a customergroup.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetAllCustomerGroupsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getAllCustomerGroupsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    currentPage,
                    pageSize,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.UserGroupList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.UserGroupList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates a new customer group.
     *
     * Creates a new customer group that is a direct subgroup of a customergroup.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {UserGroup} userGroup User group object with id and name.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createNewCustomerGroupPrimWithHttpOperationResponse(userGroup, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    userGroup,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "userGroup",
                        mapper: Object.assign({}, Mappers.UserGroup, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a specific customer group.
     *
     * Returns a customer group with a specific groupId.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} groupId Group identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetCustomerGroupOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCustomerGroupWithHttpOperationResponse(groupId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    groupId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups/{groupId}",
                    urlParameters: [
                        {
                            parameterPath: "groupId",
                            mapper: {
                                required: true,
                                serializedName: "groupId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.UserGroup
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.UserGroup;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Sets members for a user group.
     *
     * Sets members for a user group. The list of existing members is overwritten with a new one.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} groupId Group identifier.
     *
     * @param {MemberList} members List of users to set for customer group.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setUserListForCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    groupId,
                    members,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups/{groupId}/members",
                    urlParameters: [
                        {
                            parameterPath: "groupId",
                            mapper: {
                                required: true,
                                serializedName: "groupId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "members",
                        mapper: Object.assign({}, Mappers.MemberList, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Assigns user(s) to a customer group.
     *
     * Assigns user(s) to a customer group.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} groupId Group identifier.
     *
     * @param {MemberList} members List of users to assign to customer group.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    assignUserToCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    groupId,
                    members,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups/{groupId}/members",
                    urlParameters: [
                        {
                            parameterPath: "groupId",
                            mapper: {
                                required: true,
                                serializedName: "groupId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "members",
                        mapper: Object.assign({}, Mappers.MemberList, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete a user from a customer group.
     *
     * Removes user from a customer group.
     *
     * To try out the methods of the Customer Groups controller, you must authorize a user who belongs
     * to the “customermanagergroup”.
     *
     * @param {string} groupId Group identifier.
     *
     * @param {string} userId User identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removeUsersFromCustomerGroupWithHttpOperationResponse(groupId, userId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    groupId,
                    userId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/customergroups/{groupId}/members/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "groupId",
                            mapper: {
                                required: true,
                                serializedName: "groupId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of supported countries.
     *
     * Lists all supported delivery countries for the current store. The list is sorted alphabetically.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetDeliveryCountriesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getDeliveryCountriesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/deliverycountries",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CountryList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CountryList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of product exports.
     *
     * Used for product export. Depending on the timestamp parameter, it can return all products or
     * only products modified after the given time.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2ExportProductsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    exportProductsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let catalog = (options && options.catalog !== undefined) ? options.catalog : undefined;
            let version = (options && options.version !== undefined) ? options.version : undefined;
            let timestamp = (options && options.timestamp !== undefined) ? options.timestamp : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    currentPage,
                    pageSize,
                    catalog,
                    version,
                    timestamp,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/export/products",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "catalog",
                            mapper: {
                                serializedName: "catalog",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "version",
                            mapper: {
                                serializedName: "version",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "timestamp",
                            mapper: {
                                serializedName: "timestamp",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ProductList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ProductList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of orders with status updates
     *
     * Returns the orders that have changed status. Returns only the elements from the current baseSite
     * that have been updated after the provided timestamp.
     *
     * @param {string} timestamp Only items newer than the given parameter are retrieved. This
     * parameter should be in ISO-8601 format (for example, 2018-01-09T16:28:45+0000).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2OrderStatusFeedOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    orderStatusFeedWithHttpOperationResponse(timestamp, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    timestamp,
                    baseSiteId,
                    fields
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/feeds/orders/statusfeed",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "timestamp",
                            mapper: {
                                required: true,
                                serializedName: "timestamp",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.OrderStatusUpdateElementList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.OrderStatusUpdateElementList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Generates a token to restore a customer's forgotten password.
     *
     * Generates a token to restore a customer's forgotten password.
     *
     * @param {string} userId Customer's user id. Customer user id is case insensitive.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    restorePasswordWithHttpOperationResponse(userId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    userId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/forgottenpasswordtokens",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        201: {},
                        202: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of available languages.
     *
     * Lists all available languages (all languages used for a particular store). If the list of
     * languages for a base store is empty, a list of all languages available in the system will be
     * returned.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetLanguagesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getLanguagesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/languages",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.LanguageList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.LanguageList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a order
     *
     * Returns details of a specific order based on the order GUID (Globally Unique Identifier) or the
     * order CODE. The response contains detailed order information.
     *
     * @param {string} code Order GUID (Globally Unique Identifier) or order CODE
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetOrderOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getOrderWithHttpOperationResponse(code, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    code,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/orders/{code}",
                    urlParameters: [
                        {
                            parameterPath: "code",
                            mapper: {
                                required: true,
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Order
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Order;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get products added to the express update feed
     *
     * Returns products added to the express update feed. Returns only elements updated after the
     * provided timestamp. The queue is cleared using a defined cronjob.
     *
     * @param {string} timestamp Only items newer than the given parameter are retrieved from the
     * queue. This parameter should be in ISO-8601 format.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2ExpressUpdateOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    expressUpdateWithHttpOperationResponse(timestamp, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let catalog = (options && options.catalog !== undefined) ? options.catalog : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    timestamp,
                    catalog,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/expressupdate",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "timestamp",
                            mapper: {
                                required: true,
                                serializedName: "timestamp",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "catalog",
                            mapper: {
                                serializedName: "catalog",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ProductExpressUpdateElementList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ProductExpressUpdateElementList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of products and additional data
     *
     * Returns a list of products and additional data, such as available facets, available sorting, and
     * pagination options. It can also include spelling suggestions. To make spelling suggestions work,
     * you need to make sure that "enableSpellCheck" on the SearchQuery is set to "true" (by default,
     * it should already be set to "true"). You also need to have indexed properties configured to be
     * used for spellchecking.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2SearchProductsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    searchProductsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = (options && options.query !== undefined) ? options.query : undefined;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let sort = (options && options.sort !== undefined) ? options.sort : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            let searchQueryContext = (options && options.searchQueryContext !== undefined) ? options.searchQueryContext : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    query,
                    currentPage,
                    pageSize,
                    sort,
                    fields,
                    searchQueryContext,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/search",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "query",
                            mapper: {
                                serializedName: "query",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "searchQueryContext",
                            mapper: {
                                serializedName: "searchQueryContext",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ProductSearchPage
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ProductSearchPage;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a header with total number of products
     *
     * In the response header, the "x-total-count" indicates the total number of products satisfying a
     * query.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2CountSearchProductsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    countSearchProductsWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = (options && options.query !== undefined) ? options.query : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    query,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/search",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "query",
                            mapper: {
                                serializedName: "query",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of available suggestions
     *
     * Returns a list of all available suggestions related to a given term and limits the results to a
     * specific value of the max parameter.
     *
     * @param {string} term Specified term
     *
     * @param {number} max Specifies the limit of results.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetSuggestionsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getSuggestionsWithHttpOperationResponse(term, max, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    term,
                    max,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/suggestions",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "term",
                            mapper: {
                                required: true,
                                serializedName: "term",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "max",
                            mapper: {
                                required: true,
                                serializedName: "max",
                                defaultValue: 10,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SuggestionList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SuggestionList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get product details
     *
     * Returns details of a single product according to a product code.
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetProductByCodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getProductByCodeWithHttpOperationResponse(productCode, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Product
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Product;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a product reference
     *
     * Returns references for a product with a given product code. Reference type specifies which
     * references to return.
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} referenceType Reference type according to enum ProductReferenceTypeEnum
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2ExportProductReferencesOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    exportProductReferencesWithHttpOperationResponse(productCode, referenceType, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 2147483647;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    pageSize,
                    referenceType,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/references",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 2147483647,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "referenceType",
                            mapper: {
                                required: true,
                                serializedName: "referenceType",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ProductReferenceList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ProductReferenceList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get reviews for a product
     *
     * Returns the reviews for a product with a given product code.
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetProductReviewsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getProductReviewsWithHttpOperationResponse(productCode, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let maxCount = (options && options.maxCount !== undefined) ? options.maxCount : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    maxCount,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/reviews",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "maxCount",
                            mapper: {
                                serializedName: "maxCount",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.ReviewList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.ReviewList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates a new customer review as an anonymous user
     *
     * Creates a new customer review as an anonymous user.
     *
     * @param {string} productCode Product identifier
     *
     * @param {Review} review Object contains review details like : rating, alias, headline, comment
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2CreateReviewPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createReviewPrimWithHttpOperationResponse(productCode, review, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    review,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/reviews",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "review",
                        mapper: Object.assign({}, Mappers.Review, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.Review
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Review;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a product's stock level
     *
     * Returns a product's stock levels sorted by distance from the specified location, which is
     * provided using the free-text "location" parameter, or by using the longitude and latitude
     * parameters. The following two sets of parameters are available: location (required), currentPage
     * (optional), pageSize (optional); or longitude (required), latitude (required), currentPage
     * (optional), pageSize(optional).
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2SearchProductStockByLocationOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    searchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let location = (options && options.location !== undefined) ? options.location : undefined;
            let latitude = (options && options.latitude !== undefined) ? options.latitude : undefined;
            let longitude = (options && options.longitude !== undefined) ? options.longitude : undefined;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    location,
                    latitude,
                    longitude,
                    currentPage,
                    pageSize,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/stock",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "location",
                            mapper: {
                                serializedName: "location",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "latitude",
                            mapper: {
                                serializedName: "latitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "longitude",
                            mapper: {
                                serializedName: "longitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.StoreFinderStockSearchPage
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.StoreFinderStockSearchPage;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get header with a total number of product's stock levels
     *
     * In the response header, the "x-total-count" indicates the total number of a product's stock
     * levels. The following two sets of parameters are available: location (required); or longitude
     * (required), and latitude (required).
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2CountSearchProductStockByLocationOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    countSearchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let location = (options && options.location !== undefined) ? options.location : undefined;
            let latitude = (options && options.latitude !== undefined) ? options.latitude : undefined;
            let longitude = (options && options.longitude !== undefined) ? options.longitude : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    productCode,
                    location,
                    latitude,
                    longitude,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/stock",
                    urlParameters: [
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "location",
                            mapper: {
                                serializedName: "location",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "latitude",
                            mapper: {
                                serializedName: "latitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "longitude",
                            mapper: {
                                serializedName: "longitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a product's stock level for a store
     *
     * Returns a product's stock level for a particular store (in other words, for a particular point
     * of sale).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} productCode Product identifier
     *
     * @param {string} storeName Store identifier
     *
     * @param {CommerceWebservicesV2GetStockDataOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getStockDataWithHttpOperationResponse(baseSiteId, productCode, storeName, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    productCode,
                    storeName,
                    fields
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/products/{productCode}/stock/{storeName}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "productCode",
                            mapper: {
                                required: true,
                                serializedName: "productCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "storeName",
                            mapper: {
                                required: true,
                                serializedName: "storeName",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Stock
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Stock;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of promotions
     *
     * Returns promotions defined for a current base site. Requests pertaining to promotions have been
     * developed for the previous version of promotions and vouchers and therefore some of them are
     * currently not compatible with the new promotion engine.
     *
     * @param {Type} type Defines what type of promotions should be returned. Values supported for that
     * parameter are: <ul><li>all: All available promotions are returned</li><li>product: Only product
     * promotions are returned</li><li>order: Only order promotions are returned</li></ul>. Possible
     * values include: 'all', 'product', 'order'
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetPromotionsPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPromotionsPrimWithHttpOperationResponse(type, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let promotionGroup = (options && options.promotionGroup !== undefined) ? options.promotionGroup : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    type,
                    promotionGroup,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/promotions",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "type",
                            mapper: {
                                required: true,
                                serializedName: "type",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "promotionGroup",
                            mapper: {
                                serializedName: "promotionGroup",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PromotionList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PromotionList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a promotion based on code
     *
     * Returns details of a single promotion specified by a promotion code. Requests pertaining to
     * promotions have been developed for the previous version of promotions and vouchers and therefore
     * some of them are currently not compatible with the new promotion engine.
     *
     * @param {string} code Promotion identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetPromotionByCodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPromotionByCodeWithHttpOperationResponse(code, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    code,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/promotions/{code}",
                    urlParameters: [
                        {
                            parameterPath: "code",
                            mapper: {
                                required: true,
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Promotion
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Promotion;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of store locations
     *
     * Lists all store locations that are near the location specified in a query or based on latitude
     * and longitude.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2LocationSearchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    locationSearchWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = (options && options.query !== undefined) ? options.query : undefined;
            let latitude = (options && options.latitude !== undefined) ? options.latitude : undefined;
            let longitude = (options && options.longitude !== undefined) ? options.longitude : undefined;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let sort = (options && options.sort !== undefined) ? options.sort : 'asc';
            let radius = (options && options.radius !== undefined) ? options.radius : 100000;
            let accuracy = (options && options.accuracy !== undefined) ? options.accuracy : 0;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    query,
                    latitude,
                    longitude,
                    currentPage,
                    pageSize,
                    sort,
                    radius,
                    accuracy,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/stores",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "query",
                            mapper: {
                                serializedName: "query",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "latitude",
                            mapper: {
                                serializedName: "latitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "longitude",
                            mapper: {
                                serializedName: "longitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                defaultValue: 'asc',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "radius",
                            mapper: {
                                serializedName: "radius",
                                defaultValue: 100000,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "accuracy",
                            mapper: {
                                serializedName: "accuracy",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.StoreFinderSearchPage
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.StoreFinderSearchPage;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a header with the number of store locations
     *
     * In the response header, the "x-total-count" indicates the number of all store locations that are
     * near the location specified in a query, or based on latitude and longitude.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2CountLocationSearchOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    countLocationSearchWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = (options && options.query !== undefined) ? options.query : undefined;
            let latitude = (options && options.latitude !== undefined) ? options.latitude : undefined;
            let longitude = (options && options.longitude !== undefined) ? options.longitude : undefined;
            let radius = (options && options.radius !== undefined) ? options.radius : 100000;
            let accuracy = (options && options.accuracy !== undefined) ? options.accuracy : 0;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    query,
                    latitude,
                    longitude,
                    radius,
                    accuracy,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/stores",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "query",
                            mapper: {
                                serializedName: "query",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "latitude",
                            mapper: {
                                serializedName: "latitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "longitude",
                            mapper: {
                                serializedName: "longitude",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "radius",
                            mapper: {
                                serializedName: "radius",
                                defaultValue: 100000,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "accuracy",
                            mapper: {
                                serializedName: "accuracy",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a store location
     *
     * Returns store location based on its unique name.
     *
     * @param {string} storeId Store identifier (currently store name)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2LocationDetailsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    locationDetailsWithHttpOperationResponse(storeId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    storeId,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/stores/{storeId}",
                    urlParameters: [
                        {
                            parameterPath: "storeId",
                            mapper: {
                                required: true,
                                serializedName: "storeId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PointOfService
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PointOfService;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of all localized titles.
     *
     * Lists all localized titles.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetTitlesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getTitlesWithHttpOperationResponse(baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/titles",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.TitleList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.TitleList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary  Registers a customer
     *
     * Registers a customer. There are two options for registering a customer. The first option
     * requires the following parameters: login, password, firstName, lastName, titleCode. The second
     * option converts a guest to a customer. In this case, the required parameters are: guid,
     * password.
     *
     * @param {UserSignUp} user User's object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2RegisterUserPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    registerUserPrimWithHttpOperationResponse(user, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    user,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "user",
                        mapper: Object.assign({}, Mappers.UserSignUp, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.User
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.User;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get customer profile
     *
     * Returns customer profile.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getUserWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.User
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.User;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates customer profile
     *
     * Updates customer profile. Attributes not provided in the request body will be defined again (set
     * to null or default).
     *
     * @param {User} user User's object
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    putUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    user,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "user",
                        mapper: Object.assign({}, Mappers.User, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete customer profile
     *
     * Removes customer profile.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    deactivateUserWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates customer profile
     *
     * Updates customer profile. Only attributes provided in the request body will be changed.
     *
     * @param {User} user User's object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    updateUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    user,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "user",
                        mapper: Object.assign({}, Mappers.User, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get customer's addresses
     *
     * Returns customer's addresses.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetAddressesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getAddressesWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.AddressList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.AddressList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates a new address.
     *
     * Creates a new address.
     *
     * @param {Address} address Address object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2CreateAddressPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    address,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.Address
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Address;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Verifies address
     *
     * Verifies address.
     *
     * @param {Address} address Address object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2VerifyAddressPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    verifyAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    address,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/verification",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.AddressValidation
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.AddressValidation;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get info about address
     *
     * Returns detailed information about address with a given id.
     *
     * @param {string} addressId Address identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetAddressOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/{addressId}",
                    urlParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Address
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Address;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates the address
     *
     * Updates the address. Attributes not provided in the request will be defined again (set to null
     * or default).
     *
     * @param {string} addressId Address identifier.
     *
     * @param {Address} address Address object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    putAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    address,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/{addressId}",
                    urlParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete customer's address
     *
     * Removes customer's address.
     *
     * @param {string} addressId Address identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    deleteAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/{addressId}",
                    urlParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates the address
     *
     * Updates the address. Only attributes provided in the request body will be changed.
     *
     * @param {string} addressId Address identifier.
     *
     * @param {Address} address Address object
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    patchAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    address,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/addresses/{addressId}",
                    urlParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get all customer carts.
     *
     * Lists all customer carts.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetCartsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartsWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            let savedCartsOnly = (options && options.savedCartsOnly !== undefined) ? options.savedCartsOnly : false;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let sort = (options && options.sort !== undefined) ? options.sort : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    savedCartsOnly,
                    currentPage,
                    pageSize,
                    sort,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "savedCartsOnly",
                            mapper: {
                                serializedName: "savedCartsOnly",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.CartList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CartList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates or restore a cart for a user.
     *
     * Creates a new cart or restores an anonymous cart as a user's cart (if an old Cart Id is given in
     * the request).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2CreateCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createCartWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let oldCartId = (options && options.oldCartId !== undefined) ? options.oldCartId : undefined;
            let toMergeCartGuid = (options && options.toMergeCartGuid !== undefined) ? options.toMergeCartGuid : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    oldCartId,
                    toMergeCartGuid,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "oldCartId",
                            mapper: {
                                serializedName: "oldCartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "toMergeCartGuid",
                            mapper: {
                                serializedName: "toMergeCartGuid",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        201: {
                            bodyMapper: Mappers.Cart
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Cart;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a cart with a given identifier.
     *
     * Returns the cart with a given identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Cart
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Cart;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Deletes a cart with a given cart id.
     *
     * Deletes a cart with a given cart id.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    deleteCartWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Creates a delivery address for the cart.
     *
     * Creates an address and assigns it to the cart as the delivery address.
     *
     * @param {Address} address Request body parameter that contains details such as the customer's
     * first name (firstName), the customer's last name (lastName), the customer's title (titleCode),
     * the country (country.isocode), the first part of the address (line1), the second part of the
     * address (line2), the town (town), the postal code (postalCode), and the region (region.isocode).
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2CreateAndSetAddressPrimOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    createAndSetAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    address,
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/addresses/delivery",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "address",
                        mapper: Object.assign({}, Mappers.Address, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.Address
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Address;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Sets a delivery address for the cart.
     *
     * Sets a delivery address for the cart. The address country must be placed among the delivery
     * countries of the current base store.
     *
     * @param {string} addressId Address identifier
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setCartDeliveryAddressWithHttpOperationResponse(addressId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    addressId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/addresses/delivery",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "addressId",
                            mapper: {
                                required: true,
                                serializedName: "addressId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete the delivery address from the cart.
     *
     * Removes the delivery address from the cart.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removeCartDeliveryAddressWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/addresses/delivery",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Explicitly clones a cart.
     *
     * Explicitly clones a cart.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2CloneSaveCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    cloneSaveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let name = (options && options.name !== undefined) ? options.name : undefined;
            let description = (options && options.description !== undefined) ? options.description : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    name,
                    description,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/clonesavedcart",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "name",
                            mapper: {
                                serializedName: "name",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "description",
                            mapper: {
                                serializedName: "description",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get the delivery mode selected for the cart.
     *
     * Returns the delivery mode selected for the cart.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetCartDeliveryModeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/deliverymode",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.DeliveryMode
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.DeliveryMode;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Sets the delivery mode for a cart.
     *
     * Sets the delivery mode with a given identifier for the cart.
     *
     * @param {string} deliveryModeId Delivery mode identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setCartDeliveryModeWithHttpOperationResponse(deliveryModeId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    deliveryModeId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/deliverymode",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "deliveryModeId",
                            mapper: {
                                required: true,
                                serializedName: "deliveryModeId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete the delivery mode from the cart.
     *
     * Removes the delivery mode from the cart.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removeDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/deliverymode",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get all delivery modes for the current store and delivery address.
     *
     * Returns all delivery modes supported for the current base store and cart delivery address. A
     * delivery address must be set for the cart, otherwise an empty list will be returned.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetSupportedDeliveryModesOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getSupportedDeliveryModesWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/deliverymodes",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.DeliveryModeList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.DeliveryModeList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Assigns an email to the cart.
     *
     * Assigns an email to the cart. This step is required to make a guest checkout.
     *
     * @param {string} email Email of the guest user. It will be used during the checkout process.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    guestLoginWithHttpOperationResponse(email, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    email,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/email",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "email",
                            mapper: {
                                required: true,
                                serializedName: "email",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get cart entries.
     *
     * Returns cart entries.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetCartEntriesOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartEntriesWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.OrderEntryList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.OrderEntryList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Adds a product to the cart.
     *
     * Adds a product to the cart.
     *
     * @param {OrderEntry} entry Request body parameter that contains details such as the product code
     * (product.code), the quantity of product (quantity), and the pickup store name
     * (deliveryPointOfService.name).
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2AddCartEntryPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    addCartEntryPrimWithHttpOperationResponse(entry, userId, cartId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entry,
                    fields,
                    userId,
                    cartId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries",
                    urlParameters: [
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "entry",
                        mapper: Object.assign({}, Mappers.OrderEntry, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.CartModification
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CartModification;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get the details of the cart entries.
     *
     * Returns the details of the cart entries.
     *
     * @param {number} entryNumber The entry number. Each entry in a cart has an entry number. Cart
     * entries are numbered in ascending order, starting with zero (0).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetCartEntryOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entryNumber,
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries/{entryNumber}",
                    urlParameters: [
                        {
                            parameterPath: "entryNumber",
                            mapper: {
                                required: true,
                                serializedName: "entryNumber",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.OrderEntry
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.OrderEntry;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Set quantity and store details of a cart entry.
     *
     * Updates the quantity of a single cart entry and the details of the store where the cart entry
     * will be picked up. Attributes not provided in request will be defined again (set to null or
     * default)
     *
     * @param {number} entryNumber The entry number. Each entry in a cart has an entry number. Cart
     * entries are numbered in ascending order, starting with zero (0).
     *
     * @param {OrderEntry} entry Request body parameter that contains details such as the quantity of
     * product (quantity), and the pickup store name (deliveryPointOfService.name)
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2SetCartEntryPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entryNumber,
                    entry,
                    fields,
                    userId,
                    cartId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries/{entryNumber}",
                    urlParameters: [
                        {
                            parameterPath: "entryNumber",
                            mapper: {
                                required: true,
                                serializedName: "entryNumber",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "entry",
                        mapper: Object.assign({}, Mappers.OrderEntry, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.CartModification
                        },
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CartModification;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Deletes cart entry.
     *
     * Deletes cart entry.
     *
     * @param {number} entryNumber The entry number. Each entry in a cart has an entry number. Cart
     * entries are numbered in ascending order, starting with zero (0).
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removeCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entryNumber,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries/{entryNumber}",
                    urlParameters: [
                        {
                            parameterPath: "entryNumber",
                            mapper: {
                                required: true,
                                serializedName: "entryNumber",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Update quantity and store details of a cart entry.
     *
     * Updates the quantity of a single cart entry and the details of the store where the cart entry
     * will be picked up.
     *
     * @param {number} entryNumber The entry number. Each entry in a cart has an entry number. Cart
     * entries are numbered in ascending order, starting with zero (0).
     *
     * @param {OrderEntry} entry Request body parameter that contains details such as the quantity of
     * product (quantity), and the pickup store name (deliveryPointOfService.name)
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2UpdateCartEntryPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    updateCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    entryNumber,
                    entry,
                    fields,
                    userId,
                    cartId,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/entries/{entryNumber}",
                    urlParameters: [
                        {
                            parameterPath: "entryNumber",
                            mapper: {
                                required: true,
                                serializedName: "entryNumber",
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "entry",
                        mapper: Object.assign({}, Mappers.OrderEntry, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {
                            bodyMapper: Mappers.CartModification
                        },
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.CartModification;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Flag a cart for deletion.
     *
     * Flags a cart for deletion (the cart doesn't have corresponding save cart attributes anymore).
     * The cart is not actually deleted from the database. But with the removal of the saved cart
     * attributes, this cart will be taken care of by the cart removal job just like any other cart.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2FlagForDeletionOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    flagForDeletionWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/flagForDeletion",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Defines and assigns details of a new credit card payment to the cart.
     *
     * Defines the details of a new credit card, and assigns this payment option to the cart.
     *
     * @param {PaymentDetails} paymentDetails Request body parameter that contains details such as the
     * name on the card (accountHolderName), the card number (cardNumber), the card type
     * (cardType.code), the month of the expiry date (expiryMonth), the year of the expiry date
     * (expiryYear), whether the payment details should be saved (saved), whether the payment details
     * should be set as default (defaultPaymentInfo), and the billing address
     * (billingAddress.firstName, billingAddress.lastName, billingAddress.titleCode,
     * billingAddress.country.isocode, billingAddress.line1, billingAddress.line2, billingAddress.town,
     * billingAddress.postalCode, billingAddress.region.isocode)
     *
     * The DTO is in XML or .json format.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2AddPaymentDetailsPrimOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    addPaymentDetailsPrimWithHttpOperationResponse(paymentDetails, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetails,
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/paymentdetails",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "paymentDetails",
                        mapper: Object.assign({}, Mappers.PaymentDetails, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        201: {
                            bodyMapper: Mappers.PaymentDetails
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PaymentDetails;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Sets credit card payment details for the cart.
     *
     * Sets credit card payment details for the cart.
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    setPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/paymentdetails",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get information about promotions applied on cart.
     *
     * Returns information about the promotions applied on the cart. Requests pertaining to promotions
     * have been developed for the previous version of promotions and vouchers, and as a result, some
     * of them are currently not compatible with the new promotions engine.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetPromotionsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPromotionsWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/promotions",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PromotionResultList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PromotionResultList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Enables promotions based on the promotionsId of the cart.
     *
     * Enables a promotion for the order based on the promotionId defined for the cart. Requests
     * pertaining to promotions have been developed for the previous version of promotions and
     * vouchers, and as a result, some of them are currently not compatible with the new promotions
     * engine.
     *
     * @param {string} promotionId Promotion identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    applyPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    promotionId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/promotions",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "promotionId",
                            mapper: {
                                required: true,
                                serializedName: "promotionId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get information about promotions applied on cart.
     *
     * Returns information about a promotion (with a specific promotionId), that has been applied on
     * the cart. Requests pertaining to promotions have been developed for the previous version of
     * promotions and vouchers, and as a result, some of them are currently not compatible with the new
     * promotions engine.
     *
     * @param {string} promotionId Promotion identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetPromotionOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    promotionId,
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/promotions/{promotionId}",
                    urlParameters: [
                        {
                            parameterPath: "promotionId",
                            mapper: {
                                required: true,
                                serializedName: "promotionId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PromotionResultList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PromotionResultList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Disables the promotion based on the promotionsId of the cart.
     *
     * Disables the promotion for the order based on the promotionId defined for the cart. Requests
     * pertaining to promotions have been developed for the previous version of promotions and
     * vouchers, and as a result, some of them are currently not compatible with the new promotions
     * engine.
     *
     * @param {string} promotionId Promotion identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    removePromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    promotionId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/promotions/{promotionId}",
                    urlParameters: [
                        {
                            parameterPath: "promotionId",
                            mapper: {
                                required: true,
                                serializedName: "promotionId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Restore a saved cart.
     *
     * Restore a saved cart.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2RestoreSavedCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    restoreSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/restoresavedcart",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Explicitly saves a cart.
     *
     * Explicitly saves a cart.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2SaveCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    saveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let saveCartName = (options && options.saveCartName !== undefined) ? options.saveCartName : undefined;
            let saveCartDescription = (options && options.saveCartDescription !== undefined) ? options.saveCartDescription : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    saveCartName,
                    saveCartDescription,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/save",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "saveCartName",
                            mapper: {
                                serializedName: "saveCartName",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "saveCartDescription",
                            mapper: {
                                serializedName: "saveCartDescription",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a saved cart.
     *
     * Returns a saved cart for an authenticated user. The cart is identified using the "cartId"
     * parameter.
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetSavedCartOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/savedcart",
                    urlParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.SaveCartResult
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.SaveCartResult;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a list of vouchers applied to the cart.
     *
     * Returns a list of vouchers applied to the cart.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {CommerceWebservicesV2GetVouchersOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getVouchersWithHttpOperationResponse(baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/vouchers",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.VoucherList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.VoucherList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Applies a voucher based on the voucherId defined for the cart.
     *
     * Applies a voucher based on the voucherId defined for the cart.
     *
     * @param {string} voucherId Voucher identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    applyVoucherForCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    voucherId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/vouchers",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "voucherId",
                            mapper: {
                                required: true,
                                serializedName: "voucherId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete a voucher defined for the current cart.
     *
     * Removes a voucher based on the voucherId defined for the current cart.
     *
     * @param {string} voucherId Voucher identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {string} cartId Cart identifier: cart code for logged in user, cart guid for anonymous
     * user, 'current' for the last modified cart
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    releaseVoucherFromCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    voucherId,
                    baseSiteId,
                    userId,
                    cartId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/carts/{cartId}/vouchers/{voucherId}",
                    urlParameters: [
                        {
                            parameterPath: "voucherId",
                            mapper: {
                                required: true,
                                serializedName: "voucherId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get all customer groups of a customer.
     *
     * Returns all customer groups of a customer.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetAllCustomerGroupsForCustomerOptionalParams} [options] Optional
     * Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getAllCustomerGroupsForCustomerWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/customergroups",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.UserGroupList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.UserGroupList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Changes customer's login name.
     *
     * Changes a customer's login name. Requires the customer's current password.
     *
     * @param {string} newLogin Customer's new login name. Customer login is case insensitive.
     *
     * @param {string} password Customer's current password.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    changeLoginWithHttpOperationResponse(newLogin, password, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    newLogin,
                    password,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/login",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "newLogin",
                            mapper: {
                                required: true,
                                serializedName: "newLogin",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "password",
                            mapper: {
                                required: true,
                                serializedName: "password",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get order history for user
     *
     * Returns order history data for all orders placed by a specified user for a specified base store.
     * The response can display the results across multiple pages, if required.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetOrdersForUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let statuses = (options && options.statuses !== undefined) ? options.statuses : undefined;
            let currentPage = (options && options.currentPage !== undefined) ? options.currentPage : 0;
            let pageSize = (options && options.pageSize !== undefined) ? options.pageSize : 20;
            let sort = (options && options.sort !== undefined) ? options.sort : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    statuses,
                    currentPage,
                    pageSize,
                    sort,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/orders",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "statuses",
                            mapper: {
                                serializedName: "statuses",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "currentPage",
                            mapper: {
                                serializedName: "currentPage",
                                defaultValue: 0,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "pageSize",
                            mapper: {
                                serializedName: "pageSize",
                                defaultValue: 20,
                                type: {
                                    name: "Number"
                                }
                            }
                        },
                        {
                            parameterPath: "sort",
                            mapper: {
                                serializedName: "sort",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.OrderHistoryList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.OrderHistoryList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get total number of orders
     *
     * In the response header, the "x-total-count" indicates the total number of orders placed by a
     * specified user for a specified base store.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetCountOrdersForUserOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getCountOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let statuses = (options && options.statuses !== undefined) ? options.statuses : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    statuses,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "HEAD",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/orders",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "statuses",
                            mapper: {
                                serializedName: "statuses",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Post a order
     *
     * Authorizes the cart and places the order. The response contains the new order data.
     *
     * @param {string} cartId Cart code for logged in user, cart GUID for guest checkout
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2PlaceOrderOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    placeOrderWithHttpOperationResponse(cartId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let securityCode = (options && options.securityCode !== undefined) ? options.securityCode : undefined;
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    cartId,
                    securityCode,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "POST",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/orders",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "cartId",
                            mapper: {
                                required: true,
                                serializedName: "cartId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "securityCode",
                            mapper: {
                                serializedName: "securityCode",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        201: {
                            bodyMapper: Mappers.Order
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 201) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Order;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a order
     *
     * Returns specific order details based on a specific order code. The response contains detailed
     * order information.
     *
     * @param {string} code Order GUID (Globally Unique Identifier) or order CODE
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetOrderForUserByCodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getOrderForUserByCodeWithHttpOperationResponse(code, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    code,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/orders/{code}",
                    urlParameters: [
                        {
                            parameterPath: "code",
                            mapper: {
                                required: true,
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Order
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Order;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Changes customer's password
     *
     * Changes customer's password.
     *
     * @param {string} newParameter New password.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2ChangePasswordOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    changePasswordWithHttpOperationResponse(newParameter, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let old = (options && options.old !== undefined) ? options.old : undefined;
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    old,
                    newParameter,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/password",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "old",
                            mapper: {
                                serializedName: "old",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "newParameter",
                            mapper: {
                                required: true,
                                serializedName: "new",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        201: {},
                        202: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get customer's credit card payment details list.
     *
     * Return customer's credit card payment details list.
     *
     * @param {boolean} saved Type of payment details.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetPaymentInfosOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPaymentInfosWithHttpOperationResponse(saved, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    saved,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails",
                    urlParameters: [
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "saved",
                            mapper: {
                                required: true,
                                serializedName: "saved",
                                defaultValue: false,
                                type: {
                                    name: "Boolean"
                                }
                            }
                        },
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PaymentDetailsList
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PaymentDetailsList;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get customer's credit card payment details.
     *
     * Returns a customer's credit card payment details for the specified paymentDetailsId.
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {CommerceWebservicesV2GetPaymentDetailsOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'DEFAULT';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    fields,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails/{paymentDetailsId}",
                    urlParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'DEFAULT',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.PaymentDetails
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.PaymentDetails;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates existing customer's credit card payment info.
     *
     * Updates existing customer's credit card payment info based on the payment info ID. Attributes
     * not given in request will be defined again (set to null or default).
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {PaymentDetails} paymentDetails Payment details object.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    putPaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    paymentDetails,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PUT",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails/{paymentDetailsId}",
                    urlParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "paymentDetails",
                        mapper: Object.assign({}, Mappers.PaymentDetails, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        201: {},
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Delete customer's credit card payment details.
     *
     * Removes a customer's credit card payment details based on a specified paymentDetailsId.
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    deletePaymentInfoWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "DELETE",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails/{paymentDetailsId}",
                    urlParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Updates existing customer's credit card payment details.
     *
     * Updates an existing customer's credit card payment details based on the specified
     * paymentDetailsId. Only those attributes provided in the request will be updated.
     *
     * @param {string} paymentDetailsId Payment details identifier.
     *
     * @param {PaymentDetails} paymentDetails Payment details object
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {string} userId User identifier or one of the literals : 'current' for currently
     * authenticated user, 'anonymous' for anonymous user
     *
     * @param {RequestOptionsBase} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    updatePaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    paymentDetailsId,
                    paymentDetails,
                    baseSiteId,
                    userId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "PATCH",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/users/{userId}/paymentdetails/{paymentDetailsId}",
                    urlParameters: [
                        {
                            parameterPath: "paymentDetailsId",
                            mapper: {
                                required: true,
                                serializedName: "paymentDetailsId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "userId",
                            mapper: {
                                required: true,
                                serializedName: "userId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    requestBody: {
                        parameterPath: "paymentDetails",
                        mapper: Object.assign({}, Mappers.PaymentDetails, { required: true })
                    },
                    contentType: "application/json; charset=utf-8",
                    responses: {
                        200: {},
                        204: {},
                        401: {},
                        403: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    // methods on the client.
    /**
     * @summary Get a voucher based on code
     *
     * Returns details of a single voucher that is specified by its voucher identification code.
     *
     * @param {string} code Voucher identifier (code)
     *
     * @param {string} baseSiteId Base site identifier
     *
     * @param {CommerceWebservicesV2GetVoucherByCodeOptionalParams} [options] Optional Parameters.
     *
     * @returns {Promise} A promise is returned
     *
     * @resolve {HttpOperationResponse} The deserialized result object.
     *
     * @reject {Error|ServiceError} The error object.
     */
    getVoucherByCodeWithHttpOperationResponse(code, baseSiteId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fields = (options && options.fields !== undefined) ? options.fields : 'BASIC';
            // Create HTTP transport objects
            const httpRequest = new WebResource();
            let operationRes;
            try {
                const operationArguments = msRest.createOperationArguments({
                    code,
                    fields,
                    baseSiteId
                }, options);
                operationRes = yield this.sendOperationRequest(httpRequest, operationArguments, {
                    httpMethod: "GET",
                    baseUrl: this.baseUri,
                    path: "rest/v2/{baseSiteId}/vouchers/{code}",
                    urlParameters: [
                        {
                            parameterPath: "code",
                            mapper: {
                                required: true,
                                serializedName: "code",
                                type: {
                                    name: "String"
                                }
                            }
                        },
                        {
                            parameterPath: "baseSiteId",
                            mapper: {
                                required: true,
                                serializedName: "baseSiteId",
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    queryParameters: [
                        {
                            parameterPath: "fields",
                            mapper: {
                                serializedName: "fields",
                                defaultValue: 'BASIC',
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    ],
                    responses: {
                        200: {
                            bodyMapper: Mappers.Voucher
                        },
                        401: {},
                        403: {},
                        404: {},
                        default: {}
                    },
                    serializer: this.serializer
                });
                // Deserialize Response
                let statusCode = operationRes.status;
                if (statusCode === 200) {
                    let parsedResponse = operationRes.parsedBody;
                    try {
                        if (parsedResponse != undefined) {
                            const resultMapper = Mappers.Voucher;
                            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
                        }
                    }
                    catch (error) {
                        let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
                        deserializationError.request = msRest.stripRequest(httpRequest);
                        deserializationError.response = msRest.stripResponse(operationRes);
                        return Promise.reject(deserializationError);
                    }
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            return Promise.resolve(operationRes);
        });
    }
    getCardTypes(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCardTypesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCardTypesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCatalogs(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCatalogsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCatalogsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCatalog(catalogId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCatalogWithHttpOperationResponse(catalogId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCatalogWithHttpOperationResponse(catalogId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCatalogVersion(catalogId, catalogVersionId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCatalogVersionWithHttpOperationResponse(catalogId, catalogVersionId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCatalogVersionWithHttpOperationResponse(catalogId, catalogVersionId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCategories(catalogId, catalogVersionId, categoryId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCategoriesWithHttpOperationResponse(catalogId, catalogVersionId, categoryId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCategoriesWithHttpOperationResponse(catalogId, catalogVersionId, categoryId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getComponentByIdList(componentIdList, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getComponentByIdListWithHttpOperationResponse(componentIdList, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getComponentByIdListWithHttpOperationResponse(componentIdList, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getComponentById(componentId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getComponentByIdWithHttpOperationResponse(componentId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getComponentByIdWithHttpOperationResponse(componentId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPageData(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPageDataWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPageDataWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCurrencies(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCurrenciesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCurrenciesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAllCustomerGroups(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllCustomerGroupsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllCustomerGroupsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createNewCustomerGroupPrim(userGroup, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createNewCustomerGroupPrimWithHttpOperationResponse(userGroup, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createNewCustomerGroupPrimWithHttpOperationResponse(userGroup, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCustomerGroup(groupId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCustomerGroupWithHttpOperationResponse(groupId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCustomerGroupWithHttpOperationResponse(groupId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setUserListForCustomerGroupPrim(groupId, members, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setUserListForCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setUserListForCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    assignUserToCustomerGroupPrim(groupId, members, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.assignUserToCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.assignUserToCustomerGroupPrimWithHttpOperationResponse(groupId, members, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeUsersFromCustomerGroup(groupId, userId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeUsersFromCustomerGroupWithHttpOperationResponse(groupId, userId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeUsersFromCustomerGroupWithHttpOperationResponse(groupId, userId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getDeliveryCountries(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getDeliveryCountriesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getDeliveryCountriesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    exportProducts(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.exportProductsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.exportProductsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    orderStatusFeed(timestamp, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.orderStatusFeedWithHttpOperationResponse(timestamp, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.orderStatusFeedWithHttpOperationResponse(timestamp, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    restorePassword(userId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.restorePasswordWithHttpOperationResponse(userId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.restorePasswordWithHttpOperationResponse(userId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getLanguages(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getLanguagesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getLanguagesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getOrder(code, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getOrderWithHttpOperationResponse(code, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getOrderWithHttpOperationResponse(code, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    expressUpdate(timestamp, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.expressUpdateWithHttpOperationResponse(timestamp, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.expressUpdateWithHttpOperationResponse(timestamp, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    searchProducts(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.searchProductsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.searchProductsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    countSearchProducts(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.countSearchProductsWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.countSearchProductsWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getSuggestions(term, max, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getSuggestionsWithHttpOperationResponse(term, max, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getSuggestionsWithHttpOperationResponse(term, max, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getProductByCode(productCode, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getProductByCodeWithHttpOperationResponse(productCode, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getProductByCodeWithHttpOperationResponse(productCode, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    exportProductReferences(productCode, referenceType, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.exportProductReferencesWithHttpOperationResponse(productCode, referenceType, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.exportProductReferencesWithHttpOperationResponse(productCode, referenceType, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getProductReviews(productCode, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getProductReviewsWithHttpOperationResponse(productCode, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getProductReviewsWithHttpOperationResponse(productCode, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createReviewPrim(productCode, review, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createReviewPrimWithHttpOperationResponse(productCode, review, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createReviewPrimWithHttpOperationResponse(productCode, review, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    searchProductStockByLocation(productCode, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.searchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.searchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    countSearchProductStockByLocation(productCode, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.countSearchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.countSearchProductStockByLocationWithHttpOperationResponse(productCode, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getStockData(baseSiteId, productCode, storeName, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getStockDataWithHttpOperationResponse(baseSiteId, productCode, storeName, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getStockDataWithHttpOperationResponse(baseSiteId, productCode, storeName, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPromotionsPrim(type, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPromotionsPrimWithHttpOperationResponse(type, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPromotionsPrimWithHttpOperationResponse(type, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPromotionByCode(code, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPromotionByCodeWithHttpOperationResponse(code, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPromotionByCodeWithHttpOperationResponse(code, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    locationSearch(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.locationSearchWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.locationSearchWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    countLocationSearch(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.countLocationSearchWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.countLocationSearchWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    locationDetails(storeId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.locationDetailsWithHttpOperationResponse(storeId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.locationDetailsWithHttpOperationResponse(storeId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getTitles(baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getTitlesWithHttpOperationResponse(baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getTitlesWithHttpOperationResponse(baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    registerUserPrim(user, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.registerUserPrimWithHttpOperationResponse(user, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.registerUserPrimWithHttpOperationResponse(user, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getUser(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getUserWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getUserWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    putUserPrim(user, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.putUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.putUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deactivateUser(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deactivateUserWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deactivateUserWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    updateUserPrim(user, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateUserPrimWithHttpOperationResponse(user, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAddresses(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAddressesWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAddressesWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createAddressPrim(address, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    verifyAddressPrim(address, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.verifyAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.verifyAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAddress(addressId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    putAddressPrim(addressId, address, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.putAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.putAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteAddress(addressId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteAddressWithHttpOperationResponse(addressId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    patchAddressPrim(addressId, address, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.patchAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.patchAddressPrimWithHttpOperationResponse(addressId, address, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCarts(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartsWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartsWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createCart(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createCartWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createCartWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCart(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deleteCart(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deleteCartWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deleteCartWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    createAndSetAddressPrim(address, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.createAndSetAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.createAndSetAddressPrimWithHttpOperationResponse(address, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setCartDeliveryAddress(addressId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setCartDeliveryAddressWithHttpOperationResponse(addressId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setCartDeliveryAddressWithHttpOperationResponse(addressId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeCartDeliveryAddress(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeCartDeliveryAddressWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeCartDeliveryAddressWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    cloneSaveCart(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.cloneSaveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.cloneSaveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCartDeliveryMode(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setCartDeliveryMode(deliveryModeId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setCartDeliveryModeWithHttpOperationResponse(deliveryModeId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setCartDeliveryModeWithHttpOperationResponse(deliveryModeId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeDeliveryMode(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeDeliveryModeWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getSupportedDeliveryModes(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getSupportedDeliveryModesWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getSupportedDeliveryModesWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    guestLogin(email, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.guestLoginWithHttpOperationResponse(email, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.guestLoginWithHttpOperationResponse(email, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCartEntries(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartEntriesWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartEntriesWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    addCartEntryPrim(entry, userId, cartId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addCartEntryPrimWithHttpOperationResponse(entry, userId, cartId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addCartEntryPrimWithHttpOperationResponse(entry, userId, cartId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCartEntry(entryNumber, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setCartEntryPrim(entryNumber, entry, userId, cartId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removeCartEntry(entryNumber, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removeCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removeCartEntryWithHttpOperationResponse(entryNumber, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    updateCartEntryPrim(entryNumber, entry, userId, cartId, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updateCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updateCartEntryPrimWithHttpOperationResponse(entryNumber, entry, userId, cartId, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    flagForDeletion(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.flagForDeletionWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.flagForDeletionWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    addPaymentDetailsPrim(paymentDetails, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.addPaymentDetailsPrimWithHttpOperationResponse(paymentDetails, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.addPaymentDetailsPrimWithHttpOperationResponse(paymentDetails, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    setPaymentDetails(paymentDetailsId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.setPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.setPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPromotions(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPromotionsWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPromotionsWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    applyPromotion(promotionId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.applyPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.applyPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPromotion(promotionId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    removePromotion(promotionId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.removePromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.removePromotionWithHttpOperationResponse(promotionId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    restoreSavedCart(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.restoreSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.restoreSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    saveCart(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.saveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.saveCartWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getSavedCart(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getSavedCartWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getVouchers(baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getVouchersWithHttpOperationResponse(baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getVouchersWithHttpOperationResponse(baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    applyVoucherForCart(voucherId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.applyVoucherForCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.applyVoucherForCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    releaseVoucherFromCart(voucherId, baseSiteId, userId, cartId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.releaseVoucherFromCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.releaseVoucherFromCartWithHttpOperationResponse(voucherId, baseSiteId, userId, cartId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getAllCustomerGroupsForCustomer(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getAllCustomerGroupsForCustomerWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getAllCustomerGroupsForCustomerWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    changeLogin(newLogin, password, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.changeLoginWithHttpOperationResponse(newLogin, password, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.changeLoginWithHttpOperationResponse(newLogin, password, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getOrdersForUser(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getCountOrdersForUser(baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getCountOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getCountOrdersForUserWithHttpOperationResponse(baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    placeOrder(cartId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.placeOrderWithHttpOperationResponse(cartId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.placeOrderWithHttpOperationResponse(cartId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getOrderForUserByCode(code, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getOrderForUserByCodeWithHttpOperationResponse(code, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getOrderForUserByCodeWithHttpOperationResponse(code, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    changePassword(newParameter, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.changePasswordWithHttpOperationResponse(newParameter, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.changePasswordWithHttpOperationResponse(newParameter, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPaymentInfos(saved, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPaymentInfosWithHttpOperationResponse(saved, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPaymentInfosWithHttpOperationResponse(saved, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getPaymentDetails(paymentDetailsId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getPaymentDetailsWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    putPaymentInfoPrim(paymentDetailsId, paymentDetails, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.putPaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.putPaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    deletePaymentInfo(paymentDetailsId, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.deletePaymentInfoWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.deletePaymentInfoWithHttpOperationResponse(paymentDetailsId, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    updatePaymentInfoPrim(paymentDetailsId, paymentDetails, baseSiteId, userId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.updatePaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.updatePaymentInfoPrimWithHttpOperationResponse(paymentDetailsId, paymentDetails, baseSiteId, userId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
    getVoucherByCode(code, baseSiteId, options, callback) {
        if (!callback && typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let cb = callback;
        if (!callback) {
            return this.getVoucherByCodeWithHttpOperationResponse(code, baseSiteId, options).then((operationRes) => {
                return Promise.resolve(operationRes.parsedBody);
            }).catch((err) => {
                return Promise.reject(err);
            });
        }
        else {
            msRest.promiseToCallback(this.getVoucherByCodeWithHttpOperationResponse(code, baseSiteId, options))((err, data) => {
                if (err) {
                    return cb(err);
                }
                let result = data.parsedBody;
                return cb(err, result, data.request, data);
            });
        }
    }
}
exports.CommerceWebservicesV2 = CommerceWebservicesV2;
//# sourceMappingURL=commerceWebservicesV2.js.map